<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Computer composition principle" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/Computer%20composition%20principle/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:49.432Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/02/Computer%20composition%20principle/">Computer composition principle</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="计算机系统层次结构："><a href="#计算机系统层次结构：" class="headerlink" title="计算机系统层次结构："></a>计算机系统层次结构：</h2><ul>
<li>计算机硬件发展：电子管时代、晶体管时代、中小规模集成电路时代、超大规模集成电路时代</li>
<li>冯诺依曼机特点：</li>
<li><ul>
<li><p>采用“存储程序”的工作方式</p>
</li>
<li><p>计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部件组成</p>
</li>
<li><p>指令和数据以同等地位存储在存储器中，形式上没有区别，但计算机应能区分它们</p>
</li>
<li><p>指令和数据均用二进制代码表示。指令由操作码和地址码组成，操作码指出操作的类型，地址码指出操作数的地址</p>
</li>
</ul>
</li>
<li>计算机的功能部件：运算器、存储器、控制器、输入设备、输出设备</li>
<li>存储字长是1B或是字节的偶数倍</li>
<li>MAR用于寻址，其位数对应着存储单元的个数。如MAR为10位，则有1024个存储单元，记为1K。MAR的长度和PC的长度相等</li>
<li>MDR的位数和存储字长相等，一般为字节的2次幂的整数倍。</li>
<li>MAR和MDR虽然是存储器的一部分，但在现代计算机中确实存在于CPU中的；另外，Cache也在CPU中</li>
<li>运算器的算术核心是算术逻辑单元（ALU）</li>
<li>控制器由PC、IR和控制单元（CU）组成</li>
<li>CPU和主存之间通过一组总线相连，总线中有地址、控制和数据3组信号线。</li>
</ul>
<h3 id="错题小结"><a href="#错题小结" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>冯诺依曼机的基本工作方式是<strong>控制流驱动方式</strong></li>
<li>相联存储器的特点是<strong>存储器按内容选择地址</strong>，既可按地址寻址又可按内容寻址。</li>
<li>CPU存取速度：寄存器大于 Cache大于 内存</li>
<li>数据库系统一般由<strong>数据库、数据库管理系统、应用系统、数据库管理员</strong>组成，其中<strong>数据库管理系统是系统程序</strong></li>
<li>在冯诺依曼计算机中，<strong>CPU按照指令周期的不同阶段区分指令以及数据</strong></li>
<li>机器语言是计算机唯一可以直接执行的语言，汇编语言用助记符编写，以便记忆。</li>
</ol>
<h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><h3 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h3><p>​	字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与CPU的寄存器位数、加法器有关。因此，字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节的整数倍。</p>
<p>​	指令字长：指令的二进制代码的位数</p>
<p>​	存储字长：一个存储单元存储的二进制代码的位数</p>
<p>​	<strong>指令字长通常为存储字长的倍数。</strong></p>
<h3 id="数据通路带宽"><a href="#数据通路带宽" class="headerlink" title="数据通路带宽"></a>数据通路带宽</h3><p>​	数据通路带宽是指数据总线一次所能并行传输信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同。</p>
<h3 id="主存容量"><a href="#主存容量" class="headerlink" title="主存容量"></a>主存容量</h3><p>​	主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数字长（如512K*64位）来表示存储容量。</p>
<h3 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h3><ol>
<li>吞吐量和相应时间</li>
<li>主频和CPU时钟周期</li>
<li>CPI，即执行一条指令所需的时钟周期数</li>
<li>CPU执行时间，指运行一个程序所花费的时间</li>
<li>MIPS，即每秒执行多少百万条指令</li>
<li>MFLPOS、GFLOPS、TFLPOS、PFLOPS、EDLOPS、ZFLOPS</li>
</ol>
<h3 id="基准程序"><a href="#基准程序" class="headerlink" title="基准程序"></a>基准程序</h3><p>​	专门用来进行性能评价的一组程序，能够很好地反映机器在运行实际负载时的性能。</p>
<h3 id="错题小结-1"><a href="#错题小结-1" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li><p>寄存器由触发器构成</p>
</li>
<li><p>数据字长是数据总线一次能并行传送信息的位数，它可以不等于MDR的位数</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fragrant-breeze/p/12307658.html">辨析：机器字长、存储字长、指令字长和操作系统位数 - Breezerf - 博客园 (cnblogs.com)</a></p>
</li>
<li><p>汇编程序员可以通过JMP指令设置PC的值。状态寄存器、通用寄存器只有为汇编程序员可见才能实现编程，而IR，MAR，MDR是CPU的内部各自寄存器，对程序员均不可见。</p>
</li>
<li><p>周期之间的关系：</p>
<p><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F">指令周期</a>（Instruction Cycle）：取出并执行一条指令的时间。</p>
<p>CPU周期：一条指令执行过程被划分为若干阶段，每一阶段完成所需时间。</p>
<p><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F">时钟周期</a>（Clock Cycle）：又称震荡周期，是处理操作的最基本单位。</p>
<p>对于一个指令周期来说，我们取出一条指令，然后执行它，至少需要两个 CPU 周期。取出指令至少需要一个 CPU 周期，执行至少也需要一个 CPU 周期，复杂的指令则需要更多的 CPU 周期。而一个CPU周期是若干时钟周期之和。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/v2-8ebe2798fe88473446615cf2bdf7662a_720w.webp" alt="img"></p>
<p>所以，我们说一个指令周期，包含多个 CPU 周期，而一个 CPU 周期包含多个时钟周期。</p>
</li>
<li><p>计算机“运算速度”指标的含义是每秒能执行多少条指令。</p>
</li>
<li><p>用户观点看，吞吐率是评价计算机系统性能的综合参数</p>
</li>
<li><p>CPU时间为90s，若CPU速度提高50%，则CPU时间变为60s</p>
</li>
</ol>
<h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><h3 id="不同进制之间的转换"><a href="#不同进制之间的转换" class="headerlink" title="不同进制之间的转换"></a>不同进制之间的转换</h3><ol>
<li><p>二进制转为八进制、十六进制</p>
</li>
<li><p>任意进制转十进制</p>
</li>
<li><p>十进制转任意进制</p>
<p>整数部分：除基取余法</p>
<p>小数部分：乘基取整法</p>
</li>
</ol>
<blockquote>
<p>注意：不是每一个十进制小数都可以准确地用二进制表示，如0.3. <strong>但任意一个二进制小数可以用十进制小数表示</strong>.</p>
</blockquote>
<h3 id="真值与机器数"><a href="#真值与机器数" class="headerlink" title="真值与机器数"></a>真值与机器数</h3><p>带”+”或”-“符号的数称为真值.真值是机器数所代表的实际值.</p>
<h3 id="定点数的编码表示"><a href="#定点数的编码表示" class="headerlink" title="定点数的编码表示"></a>定点数的编码表示</h3><p>通常用定点补码整数表示整数,用定点原码小数表示浮点数的尾数部分,用移码表示浮点数的阶码部分.</p>
<h4 id="机器数的顶点表示"><a href="#机器数的顶点表示" class="headerlink" title="机器数的顶点表示"></a>机器数的顶点表示</h4><ol>
<li><p>机器数的定点表示</p>
<ol>
<li>定点小数(纯小数)</li>
<li>定点整数(纯整数)</li>
</ol>
</li>
<li><p>原码, 补码, 反码, 移码<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/118432554">原码、反码、补码 - 知乎 (zhihu.com)</a></p>
<ol>
<li><p>原码</p>
<ol>
<li><p>若字长为n+1,原码小数的表示范围$-(1-2^{-n}) \leq x \leq (1-2^{-n})$（关于原点对称）</p>
</li>
<li><p>若字长为n+1,原码整数的表示范围为$-(2^n-1) \leq x \leq (2^n-1)$（关于原点对称）</p>
<blockquote>
<p>注意: 真值0的原码表示有正零和负零两种形式.</p>
</blockquote>
</li>
</ol>
</li>
<li><p>补码</p>
<ol>
<li><p>若字长为n+1，补码小数的表示范围为$-1\leq x \leq 1-2^{-n}$(比原码多表示-1)</p>
</li>
<li><p>若字长为n+1，补码整数的表示范围为$-2^n\leq x\leq 2^n-1$( 比原码多表示-2^n^)</p>
<blockquote>
<p>注意：0的补码表示是唯一的，为0，0000000 &#x3D; 0. 0000000</p>
</blockquote>
</li>
<li><p>变形补码</p>
<p>模4补码双符号位00表示正，11表示负，01表示上溢，10表示下溢</p>
</li>
<li><p>补码与真值之间的转换</p>
<p>~</p>
</li>
</ol>
</li>
<li><p>反码表示法</p>
<p>~</p>
</li>
<li><p>移码表示法</p>
<p>​	<strong>移码常用来表示浮点数的阶码。它只能表示整数。</strong></p>
<p>​	移码就是在真值X上加上一个常数（偏置值），通常这个常数取2^n^，相当于X在数轴上向正方向偏移了若干单位，这就是移码一词的由来。移码定义为<br>$$<br>[x_{移}] &#x3D; 2^n + x (-2^n &lt;x &lt; 2^n,其中机器字长为n+1)<br>$$<br>​	<strong>移码的特点：</strong></p>
<ol>
<li>移码中0的表示唯一</li>
<li>一个真值的移码和补码仅差一个符号位（移码等于补码符号位取反）</li>
<li>移码全0，对应真值最小值-2^n^,移码全1，对应真值最大值2^n^</li>
<li>移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小</li>
</ol>
</li>
</ol>
</li>
<li><p>原码、补码、反码、移码这4种编码表示的总结如下：</p>
<ol>
<li>原码、补码、反码的符号位相同，整数的机器码相同</li>
<li>原码、反码的表述在数轴上对称，二者都存在+0和-0两个0</li>
<li>移码、补码的表示在数轴上不对称，0的表示唯一，它们比原码、反码多表示一个数</li>
<li>整数的补码、移码的符号位相反，数值位相同</li>
<li>负数的反码、补码末位相差1.</li>
<li>原码很容易判断大小，而负数的反码、补码很难直接判断大小，可采用如下规则快速判断：对于负数，数值部分越大，绝对值越小，真值越大（更靠近0）</li>
</ol>
</li>
</ol>
<h3 id="错题小结-2"><a href="#错题小结-2" class="headerlink" title="错题小结"></a>错题小结</h3><p>1. </p>
<h2 id="运算方法和运算电路"><a href="#运算方法和运算电路" class="headerlink" title="运算方法和运算电路"></a>运算方法和运算电路</h2><h3 id="基本运算部件"><a href="#基本运算部件" class="headerlink" title="基本运算部件"></a>基本运算部件</h3><ol>
<li><p>一位全加器</p>
</li>
<li><p>串行进位加法器</p>
</li>
<li><p>并行进位加法器</p>
</li>
<li><p>带标志加法器</p>
</li>
<li><p>算术逻辑单元（ALU）</p>
<p>ALU的核心是带标志加法器，同时也能进行“与”，“或”，“非”等逻辑运算。</p>
</li>
</ol>
<h3 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h3><ol>
<li><p>算术移位</p>
<p><strong>算术移位的对象是有符号数，因此在移位过程中符号位保持不变</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>码制</th>
<th>添补代码</th>
</tr>
</thead>
<tbody><tr>
<td>正数</td>
<td>原码、反码、补码</td>
<td>0</td>
</tr>
<tr>
<td>负数</td>
<td>原码</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>反码</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>补码</td>
<td>左移添0，右移添1</td>
</tr>
</tbody></table>
<p>三种机器数算术移位后的符号位均不变。</p>
<p>对于正数，左移时，高位丢1，结果出错。右移时，低位丢1，影响精度。</p>
<p>对于负数原码，左移时，高位丢1，结果出错。右移时，低位丢1，影响精度。</p>
<p>对于负数补码，左移时，高位丢0，结果出错。右移时，低位丢1，影响精度。</p>
<p>对于负数反码，左移时，高位丢0，结果出错。右移时，低位丢0，影响精度。</p>
</li>
<li><p>逻辑移位</p>
<p><strong>逻辑移位将操作数视为无符号数。</strong></p>
<p>移位规则：</p>
<p>逻辑左移，高位移丢，低位添0；</p>
<p>逻辑右移，低位移丢，高位添0.</p>
</li>
<li><p>循环移位</p>
<p>循环移位分为带进位标志位CF的循环移位（大循环）和不带进位标志位的循环移位（小循环）</p>
<p>循环移位特别适合将数据的低字节数据与高字节数据互换。</p>
</li>
</ol>
<h3 id="定点数的加减运算"><a href="#定点数的加减运算" class="headerlink" title="定点数的加减运算"></a>定点数的加减运算</h3><ol>
<li><p>补码的加减法运算(机器字长为n+1)<br>$$<br>[A+B]<em>{补} &#x3D; [A]</em>{补} + [B]<em>{补} (mod 2^{n+1})\<br>[A-B]</em>{补} &#x3D; [A]<em>{补} + [-B]</em>{补} (mod 2^{n+1})<br>$$</p>
</li>
<li><p>补码加减运算电路</p>
</li>
<li><p>溢出判别方法</p>
<p><strong>仅当两个符号相同的数相加或两个符号相异的数相减才有可能产生溢出。</strong>补码定点数加减运算溢出判断的方法有3种。</p>
<ol>
<li><p>采用一位符号位</p>
<p>设A的符号为A，B的符号为B，运算结果的符号为S，则溢出逻辑表达式为<br>$$<br>V &#x3D; AB\overline{S} + \overline{AB}S<br>$$<br>若V &#x3D; 0，表示无溢出；若V &#x3D; 1，表示有溢出。</p>
</li>
<li><p>采用双符号位</p>
<p>即模4运算，前面已经提到了</p>
</li>
<li><p>采用一位符号位根据数据位的进位情况判断溢出</p>
<p>若符号位的进位与最高数位的进位相同，则说明没有溢出，否则表示发生溢出。</p>
</li>
</ol>
</li>
<li><p>原码的加减法运算（了解）</p>
</li>
</ol>
<h3 id="定点数的乘除运算"><a href="#定点数的乘除运算" class="headerlink" title="定点数的乘除运算"></a>定点数的乘除运算</h3><ol>
<li><p>定点数的乘法运算</p>
<ol>
<li><p>原码一位乘法（X*Y）</p>
<p>符号位与数值位分开求，符号位进行异或操作，数值位进行相乘操作</p>
<p>X与Y的每一位相乘（最低位开始），若Y<del>n</del>&#x3D; 1，则部分积（初始为0）加上X，若Y<del>n</del> &#x3D; 0，则部分积加上0；<strong>然后右移一位</strong>，继续对Y的下一位进行相同操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230629113551504.png" alt="image-20230629113551504"></p>
</li>
<li><p>无符号数乘法运算电路</p>
</li>
<li><p>补码一位乘法（Booth算法）</p>
<p>这是一种有符号数的乘法，采用相加和相减操作计算补码数据的乘积。</p>
<p>运算规则：</p>
<ol>
<li><p>符号位参与运算，运算的数均以补码表示</p>
</li>
<li><p>被乘数一般取双符号为参与运算，部分积取双符号位，初值为0，乘数取单符号位</p>
</li>
<li><p><strong>乘数末位增设附加位y<del>n+1</del>，初值为0</strong></p>
</li>
<li><p><strong>根据（y<del>n</del>,y<del>n+1</del>）的取值来确定操作</strong></p>
<table>
<thead>
<tr>
<th>y<del>n</del>(高位)</th>
<th>y<del>n+1</del>（低位）</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>部分积右移一位</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>部分积加[X]<del>补</del>,右移一位</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>部分积加[-X]<del>补</del>,右移一位</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>部分积右移一位</td>
</tr>
</tbody></table>
</li>
<li><p>移位按补码右移规则进行</p>
</li>
<li><p><strong>按照上述算法进行n+1步操作，但第n+1步不再移位（共进行n+1次累加和n次右移）</strong></p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230629113551504.png"/>

<p>所以[x*y]<del>补</del> &#x3D; 1. 0110001, 得x*y &#x3D;  -0. 10001111</p>
</li>
</ol>
</li>
<li><p>补码乘法运算电路</p>
</li>
</ol>
</li>
<li><p>定点数的除法运算</p>
<ol>
<li><p>符号扩展</p>
</li>
<li><p>原码除法运算（不恢复余数法）</p>
<p>符号位异或运算，数值为运算先用被除数减去除数，当余数为正，商上1，余数和商左移一位；当余数为负，商上0，余数和商左移一位；当n+1步余数为负时，需加上|Y|得到第n+1步正确的余数（余数和被除数同号）</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230629160024173.png" alt="image-20230629160024173"></p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230629160024173.png"/>
</li>
<li><p>补码除法运算（加减交替法）</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230629160233383.png" alt="image-20230629160233383"></p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230629160233383.png"/></li>
</ol>
</li>
</ol>
<h3 id="C语言中的整数类型及类型转换"><a href="#C语言中的整数类型及类型转换" class="headerlink" title="C语言中的整数类型及类型转换"></a>C语言中的整数类型及类型转换</h3><ol>
<li>有符号数和无符号数的转换</li>
<li>不同字长整数之间的转换</li>
</ol>
<h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><ol>
<li>数据的“大端方式”和”小端方式“存储</li>
<li>数据按”边界对齐”方式存储</li>
<li>精简指令系统计算机RISC通常采用边界对齐方式，因为对齐方式取指令时间相同，因此能适应指令流水。</li>
</ol>
<h3 id="错题小结-3"><a href="#错题小结-3" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li><p>在定点运算器中，无论是采用双符号位还是单符号位，必须有溢出判断电路，它一般用“异或”门来实现。</p>
</li>
<li><p>模4补码具有模2补码的全部优点且更易检查<strong>加减运算</strong>中的溢出问题，而不是乘除运算。</p>
</li>
<li><p>若$[X]_{补} &#x3D; X_0.X_1X_2…X_n$，其中$X_0$为符号位，$X_1$为最高数位。当补码左移时，判断是否溢出的方法有两个：</p>
<ol>
<li><p>双符号法</p>
<p>变单符号位为双符号位，然后左移，若两符号不同则溢出，因此$X_0\neq X_1$时溢出</p>
</li>
<li><p>单符号法</p>
<p>数值位最高位进位和符号位不同则溢出，同样可知$X_0\neq X_1$时溢出</p>
</li>
</ol>
</li>
<li><p>实现N位（不包括符号位）补码一位乘时，乘积为2N+1位（加上符号位）。</p>
</li>
<li><p>补码不恢复余数除法中，异号相除时，够减商0，不够减商1.</p>
</li>
<li><p>双符号位的最高符号位代表真正的符号，而低位符号位用于参与移位操作以判断是否发生溢出。</p>
</li>
<li><p>加法器输入的低位进位信息Sub和当前所进行的是加法还是减法有关：</p>
<ol>
<li>若当前进行的是加法，则两个输入端信息位为<strong>x的补码和y的补码</strong>，Sub &#x3D; 0 ，Cout &#x3D; X + Y</li>
<li>若当前进行的是减法，则两个输入端信息为为<strong>x的补码和y的补码取反</strong>，Sub &#x3D; 1，$Cout &#x3D; X + \overline{Y} + Sub$</li>
</ol>
</li>
<li><p>判断OF：符号位进位与数值位进位异或</p>
</li>
<li><p>判断CF：视为两个无符号数相加减，最高位进位异或（加0减1）</p>
</li>
<li></li>
</ol>
<h2 id="浮点数的表示和运算"><a href="#浮点数的表示和运算" class="headerlink" title="浮点数的表示和运算"></a>浮点数的表示和运算</h2><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><ol>
<li><p>浮点数的表示格式</p>
<p>通常，浮点数表示为<br>$$<br>N &#x3D; (-1)^S \times M \times R^E<br>$$<br>式中，S取值0或1，用来决定浮点数的符号</p>
<p>M是一个二进制定点小数，称为尾数，一般用定点原码小数表示</p>
<p>E是一个二进制定点整数，称为阶码或指数，用移码表示</p>
<p>R是基数（隐含），可以规定为2、4、16等</p>
</li>
<li><p>浮点数的表示范围</p>
<p>运算结果大于最大正数称为正上溢，小于绝对值最大负数时称为负上溢，正上溢和负上溢统称为上溢。</p>
<p><strong>数据一旦产生上溢，计算机必须中断运算操作，进行溢出处理。</strong></p>
<p>当运算结果在0至最小正数之间时称为正下溢，在0至绝对值最小负数之间称为正下溢，正下溢和负下溢统称下溢。</p>
<p><strong>数据下溢时，浮点数值趋于0，计算机仅将其当作机器数处理。</strong></p>
</li>
<li><p><strong>浮点数的规格化</strong></p>
<p>所谓规格化操作，是指通过调整一个非规格化浮点数的尾数和阶码的大小，使非0的浮点数在尾数的最高数位上保证是一个有效值。</p>
<ol>
<li><p>左规</p>
<p>当运算结果的尾数的最高数位不是有效位，即出现+&#x2F;- 0.00000的形式时，需要进行左规。左规时，尾数每左移一位、阶码减1（基数为2时）。左规可能需要很多次。</p>
</li>
<li><p>右规</p>
<p>当运算结果的尾数的有效位进到小数点前面时，需要进行右规。将尾数右移一位、阶码加1（基数为2时）。需要右规时，只需进行一次。</p>
</li>
</ol>
</li>
<li><p>IEEE754标准</p>
<ol>
<li>偏置值为127，阶码表示范围理论上是-127~128，实际上是-126~127</li>
<li>阶码全0表示无穷小，阶码全1表示无穷大</li>
</ol>
</li>
<li><p>定点、浮点表示的区别</p>
<ol>
<li><p>数值的表示范围</p>
<p>字长相同，浮点表示能表示的范围大得多。</p>
</li>
<li><p>精度</p>
<p>字长相同，浮点表示精度降低。</p>
</li>
<li><p>数的运算</p>
<p>浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化，所以浮点运算比定点运算复杂。</p>
</li>
<li><p>溢出问题</p>
<p>在定点运算中，当运算结果超出数的表示范围时，发生溢出</p>
<p>浮点运算中，运算结果超出尾数表示范围却不一定溢出，只有规格化后阶码超出所能表示的范围是，才发生溢出。</p>
</li>
</ol>
</li>
</ol>
<h3 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h3><ol>
<li><p>对阶</p>
<p>对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。</p>
<p>方法：小阶对大阶，将阶码小的尾数右移，阶码加一直到两个数的阶码相等；尾数右移舍弃掉有效位会产生误差，掉精度。</p>
</li>
<li><p>尾数求和</p>
<p>尾数相加&#x2F;减后，<strong>进一步进行规格化处理。</strong></p>
</li>
<li><p>规格化</p>
<p>IEEE754规格化尾数的形式为$\pm1.\times … \times$。尾数相加减后会得到各种可能结果，例如<br>$$<br>1 .\times … \times + 1.\times … \times &#x3D; \pm 1 \times.\times … \times\<br>1 .\times … \times - 1.\times … \times &#x3D; \pm 0 .0…01\times …\times<br>$$</p>
<ol>
<li><p>右规：g当结果为$\pm 1 \times.\times … \times$时，需要进行右规。尾数右移一位，阶码加1.尾数右移时，最高位1被移到小数点前一位作为隐藏位，最后一位移出时，要考虑<strong>舍入。</strong></p>
</li>
<li><p>左规：</p>
<p>当结果位$\pm 0 .0…01\times …\times$时，需要进行左规，尾数每左移一位，阶码减1。可能需要左规多次，直到将第一位1移到小数点左边。</p>
</li>
</ol>
</li>
<li><p>舍入</p>
<p>0舍1入法</p>
<p>恒置1法</p>
<p>截断法</p>
</li>
<li><p>溢出判断</p>
<p>若一个正指数超过了最大允许值（127或1023），则发生指数上溢，<strong>产生异常</strong>。</p>
<p>若一个负指数超过了最小允许值（-126或-1022），则发生指数下溢，<strong>通常把结果按机器零处理</strong>。</p>
<ol>
<li>右规和尾数舍入</li>
<li>左规</li>
</ol>
<blockquote>
<p>注意：某些题目可能会指定尾数或阶码采用补码表示。通常采用双符号位，当尾数求和结果溢出（如尾数为$10.\times$或$01.\times$）时，需右规一次；当结果出现$00.0\times$或$11.1\times$时，需要左规，直到尾数变为$00.1\times$或$11.0\times$。</p>
</blockquote>
</li>
</ol>
<h3 id="错题小结-4"><a href="#错题小结-4" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>出现类型转换，以char -&gt; int -&gt; long -&gt; double 和 float -&gt; double最常见</li>
<li>在浮点数总位数不变的情况下，阶码位数越多，尾数位数越少，表示数的范围越大，精度越低。</li>
<li>基数越大，范围越大，但精度越低。</li>
<li>对阶操作，是将较小的阶码调整到与较大的阶码一致，因此不存在阶码减少、尾数左移的情况。</li>
<li>与非规格化浮点数相比，规格化浮点数主要是为了增加数据的表示精度</li>
<li>8421码是十进制数的编码，不是二进制数。</li>
<li>舍入是浮点数的概念，定点数没有舍入的概念。</li>
<li><strong>浮点数舍入的情况有两种：对阶和右规。</strong></li>
<li></li>
</ol>
<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h2><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><ol>
<li><p>按在计算机中的作用（层次）分类</p>
<ol>
<li>主存储器（内存）</li>
<li>辅助存储器（外存）</li>
<li>高速缓冲存储器（Cache），现代计算机通常将Cache制作在CPU中。</li>
</ol>
</li>
<li><p>按存储介质分类</p>
<p>按存储介质，存储器可分为磁表面存储器（磁盘、磁带）、磁芯存储器、半导体存储器（MOS型存储器、双极型存储器）和光存储器（光盘）。</p>
</li>
<li><p>按存取方式分类</p>
<ol>
<li><p>随机存储器（RAM）（random-access）</p>
</li>
<li><p>只读存储器（ROM）（read-only）</p>
</li>
<li><p>串行访问存储器。</p>
<p>对存储单元进行读、写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘，光盘）。</p>
<p>直接存取不像RAM那样随机访问，也不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻找整个存储器中的某个小区域，再在小区域内顺序查找。</p>
</li>
</ol>
</li>
<li><p>按信息的可保存性分类</p>
</li>
</ol>
<h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p>​	<strong>存储容量、单位成本和存储速度</strong>，这三个指标相互制约，设计存储器系统所追求的目标就是大容量，低成本和高速度。</p>
<ol>
<li><p>存储容量 &#x3D; 存储字数 * 字长</p>
</li>
<li><p>单位成本： 每位价格 &#x3D; 总成本&#x2F;总容量</p>
</li>
<li><p>存储速度：数据传输率 &#x3D; 数据的宽度&#x2F;存取周期（或称存储周期）</p>
<ol>
<li>存取时间（$T_a$）：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</li>
<li>存取周期（$T_m$）：存取周期又称读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间。即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。</li>
<li>主存带宽（$B_m$）：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字&#x2F;秒、字节&#x2F;秒或位&#x2F;秒。</li>
</ol>
<p>存取时间不等于存取周期，通常存取周期大于存取时间。这是因为对任何一种存储器，在读写操作后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达$T_m &#x3D; 2T_a$，因为存储器中的信息读出后需要马上再生。</p>
<p><strong>存取周期和存取时间的关系：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230702010854558.png" alt="image-20230702010854558"></p>
</li>
</ol>
<h3 id="多级层次的存储系统"><a href="#多级层次的存储系统" class="headerlink" title="多级层次的存储系统"></a>多级层次的存储系统</h3><p>为了解决存储系统大容量、高速度、低成本3个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230702011523876.png" alt="image-20230702011523876"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230702011533118.png" alt="image-20230702011533118"></p>
<h3 id="错题小结-5"><a href="#错题小结-5" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项）去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入，所以它是按内容或地址进行寻址的，价格较为昂贵。一般用来制作TLB、相联Cache等。</li>
<li>CD-ROM：只读型光盘存储器，采取顺序存取方式</li>
<li>Cache&#x2F;主存系统的效率 &#x3D; Cache时间&#x2F;平均时间（这里可假设Cache时间为1）</li>
</ol>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><p>​	主存储器由DRAM实现，靠处理器的那一层（Cache）则由SRAM实现，它们都属于易失性存储器，只要电源被切断，原来保存的信息便会丢失。ROM属于非易失性存储器。</p>
<h3 id="SRAM芯片和DRAM芯片"><a href="#SRAM芯片和DRAM芯片" class="headerlink" title="SRAM芯片和DRAM芯片"></a>SRAM芯片和DRAM芯片</h3><ol>
<li><p>SRAM的工作原理</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704171644314.png" alt="image-20230704171644314"></p>
</li>
<li><p>DRAM的工作原理</p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704171644314.png"/>
</li>
<li><p>DRAM芯片的读写周期<br><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704171709783.png" alt="image-20230704171709783"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704171718684.png" alt="image-20230704171718684"></p>
</li>
<li><p>SRAM和DRAM的比较<br><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704171732525.png" alt="image-20230704171732525"></p>
</li>
<li><p>存储器芯片的内部结构</p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704171732525.png"/>

<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704171759105.png" alt="image-20230704171759105"></p>
</li>
</ol>
<h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><ol>
<li><p>只读存储器（ROM）的特点</p>
<ol>
<li>结构简单，所以位密度比可读写存储器的高。</li>
<li>具有非易失性，所以可靠性高。</li>
</ol>
</li>
<li><p>ROM的类型</p>
<ol>
<li>掩模式只读存储器（MROM）</li>
<li>一次可编程只读存储器（PROM）</li>
<li>可擦除可编程只读存储器（EPROM）</li>
<li>Flash存储器</li>
<li>固态硬盘（Solid State Drives，SSD）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704172316479.png" alt="image-20230704172316479"></p>
</li>
</ol>
<h3 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h3><p>​	<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704173140968.png"/></p>
<h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p>​	多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率。常用的有单体多字存储器和多体低位交叉存储器。</p>
<blockquote>
<p>CPU的速度比存储器快，若同时从存储器中取出多条指令，就可充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想给出的。</p>
</blockquote>
<ol>
<li><p>单体多字存储器</p>
<p>​	单体多字系统特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字，地址必须顺序排列并处于同&#x3D;同一存储单元。</p>
<p>​	单体多字系统在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1&#x2F;m个存取周期，CPU向主存取一条指令。这<strong>显然提高了单体存储器的工作速度</strong>。</p>
<p>​	<strong>缺点</strong>：指令和数据在主存内必须是连续存放的，一旦遇到转移指令或操作数不能连续存放，这种方法的效果就不明显。</p>
</li>
<li><p>多体并行存储器</p>
<p>​	多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。他们既能并行工作，又能交叉工作。</p>
<p>​	多体并行存储器分为高位交叉编址和低位交叉编址两种。</p>
<ol>
<li><p>高位交叉编址（顺序方式）</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704174413435.png" alt="image-20230704174413435"></p>
</li>
<li><p>低位交叉编址（交叉方式）</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704202054405.png" alt="image-20230704202054405"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230704202103534.png" alt="image-20230704202103534"></p>
</li>
</ol>
</li>
</ol>
<h3 id="错题小结-6"><a href="#错题小结-6" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li><p>芯片引脚数目为地址线+数据线+片选线+读写线</p>
<blockquote>
<p>若采用地址复用技术，地址线数量可减半，同时需要加入行通选线以及列通选线，并且片选线可用行通选线代替，</p>
<p>即引脚数目为地址线（减半）+数据线+行通选+列通选+读写线+片选线（可选）</p>
</blockquote>
</li>
<li><p>低位多体交叉存储器能很好的满足程序的局部性原理。</p>
</li>
<li><p>高位四体交叉存储器也可能在一个存储周期内连续访问4个模块（每个模块地址间隔一个存储芯片容量）</p>
</li>
<li><p>双端口存储器当两个端口的地址码相同且都为读操作时才会发送冲突。</p>
</li>
<li><p>关于ROM，若可读可写，写的速度一定比读的慢，因为写操作需要先将读的数据擦除再进行写入。</p>
</li>
<li><p><strong>DRAM默认采用地址复用技术，在计算芯片引脚数时特别注意</strong></p>
</li>
<li><p><strong>在一个存储周期内访问相同的模块，即可能发生冲突。</strong></p>
</li>
<li><p>低位四体交叉存储器，一个存储周期可对每个芯片各读取1字节（字节编址），若要读取一个double类型数据且该数据起始地址位于第2模块，则需要3个存储周期数才能读出。</p>
</li>
<li><p>动态RAM采用分散刷新方式时，不存在死时间</p>
</li>
<li><p>随机存取和随机存取存储器（RAM）不同，支持随机存取的不一定是RAM，ROM也支持随机存取</p>
</li>
<li></li>
</ol>
<h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h3 id="连接原理"><a href="#连接原理" class="headerlink" title="连接原理"></a>连接原理</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230705161529280.png" alt="image-20230705161529280"></p>
<h3 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h3><ol>
<li><p>位扩展法<br><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230705163158156.png" alt="image-20230705163158156"></p>
</li>
<li><p>字扩展法<br><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230705163207631.png" alt="image-20230705163207631"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230705163234468.png" alt="image-20230705163234468"></p>
</li>
<li><p>字位同时扩展法<br><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230705163245880.png" alt="image-20230705163245880"></p>
</li>
</ol>
<h3 id="存储芯片的地址分配与片选"><a href="#存储芯片的地址分配与片选" class="headerlink" title="存储芯片的地址分配与片选"></a>存储芯片的地址分配与片选</h3><ol>
<li>线选法</li>
<li>译码片选法</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230705163955311.png" alt="image-20230705163955311"></p>
<h3 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h3><ol>
<li>合理选择存储芯片</li>
<li>地址线的连接</li>
<li>数据线的连接</li>
<li>读&#x2F;写命令线的连接</li>
<li>片选线的连接</li>
</ol>
<h3 id="错题小结-7"><a href="#错题小结-7" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>字扩展时，译码位置应当是地址位的前几位，如总共有16位，后12位为芯片地址位，有4个芯片，那么高3、4位即为译码位而不是高1、2位。<strong>切记勿将默认最高位当成译码位。</strong></li>
<li>考虑到存储器扩展的需要，MAR应保证到能访问到整个主存地址空间，反过来，MAR决定了主存地址空间的大小。</li>
</ol>
<h2 id="外部存储器"><a href="#外部存储器" class="headerlink" title="外部存储器"></a>外部存储器</h2><h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><p>优点：</p>
<ol>
<li>存储容量大，位价格低。</li>
<li>记录介质可重复使用。</li>
<li>记录信息可长期保存而不丢失，甚至可脱机存档。</li>
<li>非破坏性读出，读出时不需要再生。</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>存取速度慢</p>
</li>
<li><p>机械结构复杂</p>
</li>
<li><p>对工作环境要求较高</p>
</li>
<li><p>磁盘存储器</p>
<ol>
<li><p>磁盘设备的组成</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706014028898.png" alt="image-20230706014028898"></p>
</li>
<li><p>磁记录原理</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706014035624.png" alt="image-20230706014035624"></p>
</li>
<li><p>磁盘的性能指标</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706014042103.png" alt="image-20230706014042103"></p>
</li>
<li><p>磁盘地址</p>
<p>主机向磁盘控制器发送寻址信息，磁盘的地址一般如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706014226245.png" alt="image-20230706014226245"></p>
</li>
<li><p>磁盘的工作过程（上图）</p>
</li>
</ol>
</li>
<li><p>磁盘阵列</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706014714696.png" alt="image-20230706014714696"></p>
</li>
</ol>
<h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><p>​	<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706014742915.png" alt="image-20230706014742915"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706014759930.png" alt="image-20230706014759930"></p>
<h3 id="错题小结-8"><a href="#错题小结-8" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>访问一个扇区的存取时间 &#x3D; 寻道时间 + 旋转延迟时间 + 数据传输时间</li>
<li>固态硬盘（SSD）的随机读写性能明显高于磁盘，因其没有机械移动的部件，但SSD易磨损。</li>
</ol>
<h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><h3 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h3><p>​	……</p>
<h3 id="Cache的基本工作原理"><a href="#Cache的基本工作原理" class="headerlink" title="Cache的基本工作原理"></a>Cache的基本工作原理</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706170340062.png" alt="image-20230706170340062"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706170348417.png" alt="image-20230706170348417"></p>
<h3 id="Cache和主存的映射方式"><a href="#Cache和主存的映射方式" class="headerlink" title="Cache和主存的映射方式"></a>Cache和主存的映射方式</h3><ol>
<li><p>直接映射</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706170437986.png" alt="image-20230706170437986"></p>
</li>
<li><p>全相联映射</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706170824089.png" alt="image-20230706170824089"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706170832274.png" alt="image-20230706170832274"></p>
</li>
<li><p>组相联映射</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706171345649.png" alt="image-20230706171345649"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706195742630.png" alt="image-20230706195742630"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706195755789.png" alt="image-20230706195755789"></p>
</li>
</ol>
<h3 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706200749450.png" alt="image-20230706200749450"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706200805467.png" alt="image-20230706200805467"></p>
<h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706201637174.png" alt="image-20230706201637174"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230706201646070.png" alt="image-20230706201646070"></p>
<h3 id="错题小结-9"><a href="#错题小结-9" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>地址映射表即为标记阵列，每个Cache行对应一个标记项（包括<strong>有效位、标记位Tag、一致性维护位、替换算法控制位</strong>）。</li>
<li>Cache行的内容为标记项+数据项。</li>
<li>只有在虚拟存储器中，CPU发出的才是虚拟地址，其他情况均为主存地址。</li>
<li>关于Cache一次缺失损失多少个时钟周期的问题需要加深理解。P120：T14、T15</li>
<li>在进行组相联映射时，需要将主存地址的高位（Tag标记）与分组中n个Cache行的Tag标记做<strong>并行比较</strong>，因此组内有多少行就需要有多少个比较器，而比较器的位数取决于Tag的位数。</li>
<li>注意在计算Cache行号的时候是用<strong>主存的块号</strong> mod Cache的行数，而主存的块号 &#x3D; 主存地址 &#x2F; 块的大小(向下取整)</li>
</ol>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>​	主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量。</p>
<h3 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230708173111455.png" alt="image-20230708173111455"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230708173119607.png" alt="image-20230708173119607"></p>
<h3 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h3><ol>
<li><p>页表</p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230708220928414.png"/>
</li>
<li><p>快表（TLB）</p>
<p>类似Cache的一个存储器，用于存放经常访问的页项。常采用全相联或组相联方式。每个TLB项都由一个TLB标记字段+页表表项内容组成。</p>
<p>全相联方式下：标记字段即为虚拟页号</p>
<p>组相联方式下：标记字段为虚拟页号的高位，而虚拟页号的低位则为TLB组索引。</p>
</li>
<li><p>具有TLB和Cache的多级存储系统</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230708223112625.png" alt="image-20230708223112625"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230708223103016.png" alt="image-20230708223103016"></p>
</li>
</ol>
<h3 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h3><p>优点：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译，管理和保护，也便于多道程序的共享；</p>
<p>缺点：因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p>
<h3 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230708224256093.png" alt="image-20230708224256093"></p>
<h3 id="虚拟存储器与Cache的比较"><a href="#虚拟存储器与Cache的比较" class="headerlink" title="虚拟存储器与Cache的比较"></a>虚拟存储器与Cache的比较</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230708224326785.png" alt="image-20230708224326785"></p>
<h3 id="错题小结-10"><a href="#错题小结-10" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>段式虚拟存储器在与主存交换信息时的单位为段。</li>
<li>页式、段页式均仅采用页。</li>
<li>虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是在程序的执行过程中，程序对主存的访问是不均匀的。</li>
<li>重点关注虚拟存储器与Cache的比较</li>
<li>在虚拟存储器中，当程序正在执行时，由操作系统完成地址映射。</li>
<li>页式虚拟存储器中，页面若很小，虚拟存储器中包含的页面数就会过多，使得页表的体积过大，导致页表本身占据的存储空间过大，使操作速度变慢。当页面很大时，虚拟存储器中的页面会变少，由于主存的容量比虚拟存储器的容量小，主存中的页面数会更少，每次装入页面的时间会变长，每当需要装入新的页面时，速度会变慢。</li>
<li>快表不存储于主存中，慢表存储于主存中。</li>
<li>Cache由SRAM组成；TLB通常由相联存储器组成，也可由SRAM组成。</li>
</ol>
<h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统-1"><a href="#指令系统-1" class="headerlink" title="指令系统"></a>指令系统</h2><h3 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h3><p>操作码+地址码</p>
<ol>
<li>零地址指令</li>
<li>一地址指令</li>
<li>二地址指令</li>
<li>三地址指令</li>
<li>四地址指令</li>
</ol>
<h3 id="定长操作码指令格式"><a href="#定长操作码指令格式" class="headerlink" title="定长操作码指令格式"></a>定长操作码指令格式</h3><p>一般n位操作码字段的指令系统最大能够表示$2^n$条指令。</p>
<h3 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h3><p>~</p>
<h3 id="指令的操作类型"><a href="#指令的操作类型" class="headerlink" title="指令的操作类型"></a>指令的操作类型</h3><ol>
<li>数据传送</li>
<li>算术和逻辑运算</li>
<li>移位操作</li>
<li>转移操作</li>
<li>输入输出操作</li>
</ol>
<h3 id="错题小结-11"><a href="#错题小结-11" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>指令系统是计算机硬件的语言系统，这显然和机器语言有关。</li>
<li>中断指令是由硬件实现的，并不是指令系统中存在的指令，更不可能属于程序控制类指令。</li>
<li>单操作数指令只有一个地址码，在完成两个操作数的算术运算时，一个操作数由地址码给出，另一个操作数通常存放在累加寄存器（ACC）中，属于<strong>隐含寻址。</strong></li>
</ol>
<h2 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h2><h3 id="指令寻址和数据寻址"><a href="#指令寻址和数据寻址" class="headerlink" title="指令寻址和数据寻址"></a>指令寻址和数据寻址</h3><ol>
<li><p>指令寻址</p>
<ol>
<li><p>顺序寻址</p>
<p>通过程序计数器PC+1（一个指令字长）自动形成下一条指令的地址</p>
</li>
<li><p>跳跃寻址</p>
<p>通过转移类指令实现，跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过PC给出。</p>
</li>
</ol>
</li>
<li><p>数据寻址</p>
<p>数据寻址的方式较多，通常在指令字中设一个<strong>寻址特征字段</strong>来区别各种寻址方式。</p>
</li>
</ol>
<h3 id="常见的数据寻址方式"><a href="#常见的数据寻址方式" class="headerlink" title="常见的数据寻址方式"></a>常见的数据寻址方式</h3><ol>
<li><p>隐含寻址</p>
<p>有利于缩短指令字长；</p>
<p>需增加存储操作数或隐含地址的硬件。</p>
</li>
<li><p>立即（数）寻址</p>
<p>执行阶段不访问主存，指令执行时间最短；</p>
<p>A的位数限制了立即数的范围。</p>
</li>
<li><p>直接寻址</p>
<p>简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址；</p>
<p>A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。</p>
</li>
<li><p>间接寻址</p>
<p>可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（可方便地完成子程序返回）；</p>
<p>指令在执行阶段要多次访存，由于访存速度过慢，这种寻址方式并不常用。一般问到扩大寻址范围时，通常指的是<strong>寄存器间接寻址</strong>。</p>
</li>
<li><p>寄存器寻址</p>
<p>指令在执行阶段不访问主存，只访问寄存器，因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量&#x2F;矩阵运算；</p>
<p>寄存器价格昂贵，计算机中的寄存器个数有限。</p>
</li>
<li><p>寄存器间接寻址</p>
<p>比一般间接寻址速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）</p>
</li>
<li><p>相对寻址</p>
<p>EA &#x3D; （PC） +  A，注意此处A用补码表示</p>
<p>操作数的地址不是固定的，它随PC的值变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。相对寻址广泛用于转移指令。</p>
</li>
<li><p>基址寻址</p>
<p>EA &#x3D; （BR）+	A，BR为基址寄存器，可采用专用寄存器，又可采用通用寄存器</p>
<p>扩大寻址范围，用户不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编址浮动程序，</p>
<p>但偏移量（形式地址A）的位数较短。</p>
</li>
<li><p>变址寻址</p>
<p>EA &#x3D; （IX） +	A，IX为变址寄存器，可采用专用寄存器，又可采用通用寄存器</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230710113311846.png" alt="image-20230710113311846"></p>
</li>
<li><p>堆栈寻址</p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230710113228226.png"/></li>
</ol>
<h3 id="错题小结-12"><a href="#错题小结-12" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>指令系统中采用不同寻址方式的目的是缩短指令字长、扩大寻址空间、提高编程的灵活性</li>
<li>使用转移指令实现程序控制。</li>
<li>简化地址结构的基本方法是尽量采用隐地址。</li>
<li>在多道程序设计中，最重要的寻址方式是相对寻址。</li>
</ol>
<h2 id="程序的机器级代码表示"><a href="#程序的机器级代码表示" class="headerlink" title="程序的机器级代码表示"></a>程序的机器级代码表示</h2><h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><p>CPU由运算器和控制器组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令；运算器的功能是对数据进行加工。CPU的具体功能包括：</p>
<ol>
<li>指令控制</li>
<li>操作控制</li>
<li>时间控制</li>
<li>数据加工</li>
<li>中断处理</li>
</ol>
<h3 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h3><ol>
<li><p>运算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230710202525137.png" alt="image-20230710202525137"></p>
</li>
<li><p>控制器</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230710202551024.png" alt="image-20230710202551024"></p>
</li>
</ol>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>CPU从主存中取出并执行一条指令的时间称为指令周期，不同周期的指令周期可能不同。</p>
<p>指令周期常用若干机器周期表示。</p>
<p>一个机器周期又包括若干时钟周期（也称节拍或T周期，是CPU操作的最基本单位）。</p>
<p>每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。</p>
<p>一个完整的指令周期包括取指周期、间址周期、执行周期和中断周期。</p>
<p>上述四个周期都有访存操作，只是访存目的不同。取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。</p>
<p>CPU内4个标志触发器FE、IND、EX和INT分别代表四个周期，并以状态“1”表示有效。</p>
<blockquote>
<p>注意：中断周期的进栈操作是SP-1，与传统意义上的进栈操作相反，这是因为计算机中的堆栈都是向低地址增加。</p>
</blockquote>
<h3 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h3><ol>
<li>取址周期</li>
<li>间址周期</li>
<li>执行周期</li>
<li>中断周期</li>
</ol>
<h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><ol>
<li>单指令周期</li>
<li>多指令周期</li>
<li>流水线方案</li>
</ol>
<h3 id="错题小结-13"><a href="#错题小结-13" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>采用DMA方式传递数据时，每传送一个数据就要占用一个存取周期。</li>
<li>指令总是根据程序计数器从主存中读出。</li>
<li>通常把通过一次总线事务访问一次主存或I&#x2F;O的时间定为一个机器周期。</li>
<li>由于CPU的内部操作的速度较快，而CPU访问一次存储器的时间较长，因此机器周期通常由存取周期来决定。</li>
<li>控制器可区分存储单元中存放的是指令还是数据。</li>
<li>指令字长等于存储字长，取址周期等于机器周期。</li>
<li>每个指令周期一定大于或等于一个CPU时钟周期。</li>
</ol>
<h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><h3 id="数据通路的功能"><a href="#数据通路的功能" class="headerlink" title="数据通路的功能"></a>数据通路的功能</h3><p>数据在功能部件之间传送的路径称为数据通路，由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号。数据通路的功能是实现CPU内部的运算器与寄存器及寄存器之间的数据交换。</p>
<h3 id="数据通路的基本结构"><a href="#数据通路的基本结构" class="headerlink" title="数据通路的基本结构"></a>数据通路的基本结构</h3><ol>
<li>CPU内部单总线方式</li>
<li>CPU内部多总线方式</li>
<li>专用数据通路方式</li>
</ol>
<blockquote>
<p>注意：内部总线是指同一部件内的总线，系统总线是指连接同一台计算机系统各部件的总线。</p>
</blockquote>
<ol>
<li>寄存器之间的数据传送</li>
<li>主存与CPU之间的数据传送</li>
<li>执行算术或逻辑运算</li>
</ol>
<h3 id="错题小结-14"><a href="#错题小结-14" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>采用CPU内部总线方式的数据通路的特点：结构简单、实现容易、性能较低，存在较多的冲突现象</li>
<li>不采用CPU内部总线方式的数据通路的特点：结构复杂、硬件量大、不易实现、性能高、基本不存在数据冲突现象</li>
<li>控制信号是CU根据指令操作码发出的信号，对于单周期指令来说，每条指令的执行只有一个时钟周期，而在一个时钟周期内控制信号并不会变化；若是多周期处理器，则指令的执行需要多个时钟周期，在每个时钟周期控制器会发出不同信号。</li>
</ol>
<h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="控制器的结构和功能"><a href="#控制器的结构和功能" class="headerlink" title="控制器的结构和功能"></a>控制器的结构和功能</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230711154806040.png" alt="image-20230711154806040"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230711154816188.png" alt="image-20230711154816188"></p>
<h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><ol>
<li>硬布线控制单元图</li>
<li>硬布线控制器的时序系统及微操作</li>
<li>CPU的控制方式</li>
<li>硬布线控制单元设计步骤</li>
</ol>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><ol>
<li><p>微程序控制的基本概念</p>
<ol>
<li>微命令与微操作</li>
<li>微指令与微周期</li>
<li>主存储器与控制存储器</li>
<li>程序与微程序</li>
</ol>
</li>
<li><p>微程序控制器的组成和工作过程</p>
</li>
<li><p>微指令的编码方式</p>
<ol>
<li>直接编码（直接控制）方式</li>
<li>字段直接编码方式</li>
<li>字段间接编码方式</li>
</ol>
</li>
<li><p>微指令的地址形成方式</p>
<ol>
<li>直接由微指令的下地址字段指出</li>
<li>根据机器指令的操作码形成</li>
</ol>
<ul>
<li>增量计数器法（CMAR）+	1	-&gt;	CMAR</li>
<li>根据各种标志决定微指令分支转移的地址</li>
<li>通过测试网络形成</li>
<li>由硬件直接产生微程序入口地址</li>
</ul>
</li>
<li><p>微指令的格式</p>
<ol>
<li><p>水平型微指令</p>
<p>优点：微程序短，执行速度快</p>
<p>缺点：微指令长，编写微程序比较麻烦</p>
</li>
<li><p>垂直型微指令</p>
<p>优点：微指令短，简单，规整</p>
<p>缺点：微程序长，工作效率低</p>
</li>
<li><p>混合型微指令</p>
<p>微指令较短，仍便于编写；微程序也不长，执行速度加快。</p>
</li>
<li><p>水平型微指令和垂直型微指令的比较：</p>
<ol>
<li>水平型微指令并行操作能力强、效率高、灵活性强；垂直型微指令则较差</li>
<li>水平型微指令执行一条指令的时间短；垂直型微指令执行的时间长</li>
<li>由水平型微指令解释指令的微程序，具有微指令字较长但微程序短的特点；垂直型微指令则与之相反，其微指令字较短而微程序长</li>
<li>水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对容易掌握</li>
</ol>
</li>
</ol>
</li>
<li><p>微程序控制单元的设计步骤</p>
</li>
<li><p>动态微程序设计和毫微程序设计</p>
</li>
<li><p>硬布线和微程序控制器的特点</p>
<ol>
<li><p>硬布线控制器的特点</p>
<p>硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快。</p>
<p>缺点是由于将控制部件视为专门产生固定时序信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，就不可能通过其他额外修改添加新功能。</p>
</li>
<li><p>微程序控制器的特点</p>
<p>微程序控制器的优点是同组合逻辑控制器相比，微程序控制器具有规整性、灵活性、可维护性等一系列优点；</p>
<p>缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中去一次，影响速度。</p>
<table>
<thead>
<tr>
<th>对比项目\类别</th>
<th>微程序控制器</th>
<th>硬布线控制器</th>
</tr>
</thead>
<tbody><tr>
<td>工作原理</td>
<td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td>
<td>微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生</td>
</tr>
<tr>
<td>执行速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>规整性</td>
<td>较规整</td>
<td>繁琐、不规整</td>
</tr>
<tr>
<td>应用场合</td>
<td>CISC CPU</td>
<td>RISC CPU</td>
</tr>
<tr>
<td>易扩充性</td>
<td>易扩充修改</td>
<td>困难</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="错题小结-15"><a href="#错题小结-15" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>CU（控制单元）的输入信号来源如下：<ol>
<li>经过指令译码器移码产生的指令信息</li>
<li>时序系统产生的机器周期信号和节拍信号</li>
<li>来自执行单元的反馈信息即标志。</li>
<li>前两者是主要因素。</li>
</ol>
</li>
<li>汇编程序员可见的寄存器有基址寄存器、状态&#x2F;标志寄存器、程序计数器以及通用寄存器组；而MAR、MDR、IR是CPU的内部工作寄存器，对汇编程序员不可见。</li>
</ol>
<h2 id="异常和中断机制"><a href="#异常和中断机制" class="headerlink" title="异常和中断机制"></a>异常和中断机制</h2><h3 id="异常和中断的基本概念"><a href="#异常和中断的基本概念" class="headerlink" title="异常和中断的基本概念"></a>异常和中断的基本概念</h3><p>异常是CPU执行一条指令时，由CPU在其内部检测到的、与正在执行的指令相关的同步事件。</p>
<p>中断是一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件。</p>
<h3 id="异常和中断的分类"><a href="#异常和中断的分类" class="headerlink" title="异常和中断的分类"></a>异常和中断的分类</h3><ol>
<li><p>异常的分类</p>
<ol>
<li>故障</li>
<li>自陷</li>
<li>终止</li>
</ol>
<p>故障异常和自陷异常属于程序性异常（软件中断）</p>
<p>终止异常和外中断属于硬件中断。</p>
</li>
<li><p>中断的分类</p>
<ol>
<li>可屏蔽中断</li>
<li>不可屏蔽中断</li>
</ol>
</li>
<li><p>中断和异常在本质上是一样的。但它们之间由两个重要的不同点：</p>
<ol>
<li>“缺页”或“溢出”等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成。</li>
<li>异常的检测由CPU自身完成，不必通过外部的某个信号通知CPU，对于中断，CPU必须通过中断请求线获取中断源的信息，才能知道哪个设备发生了何种中断。</li>
</ol>
</li>
</ol>
<h3 id="异常和中断响应过程"><a href="#异常和中断响应过程" class="headerlink" title="异常和中断响应过程"></a>异常和中断响应过程</h3><ol>
<li>关中断</li>
<li>保存断点和程序状态</li>
<li>识别异常和中断并转到相应的处理程序</li>
</ol>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><h3 id="指令流水线的基本概念"><a href="#指令流水线的基本概念" class="headerlink" title="指令流水线的基本概念"></a>指令流水线的基本概念</h3><ol>
<li><p>时间上并行</p>
<p>将一个任务拆分为几个不同的子阶段在不同的功能部件上并行执行</p>
</li>
<li><p>空间上并行</p>
<p>在一个处理机内设置多个执行相同任务的功能部件，并让这些部件并行工作，这样的处理机被称为超标量处机。</p>
</li>
</ol>
<h3 id="流水线的基本实现"><a href="#流水线的基本实现" class="headerlink" title="流水线的基本实现"></a>流水线的基本实现</h3><h3 id="流水线的冒险与处理"><a href="#流水线的冒险与处理" class="headerlink" title="流水线的冒险与处理"></a>流水线的冒险与处理</h3><ol>
<li>结构冒险（资源冲突）</li>
<li>数据冒险（数据冲突）</li>
<li>控制冒险（控制冲突）</li>
</ol>
<h3 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h3><ol>
<li>流水线的吞吐率</li>
<li>流水线的加速比</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230712155001020.png" alt="image-20230712155001020"></p>
<h3 id="高级流水线技术"><a href="#高级流水线技术" class="headerlink" title="高级流水线技术"></a>高级流水线技术</h3><ol>
<li>超标量流水线技术</li>
<li>超长指令字技术</li>
<li>超流水线技术</li>
</ol>
<h3 id="错题小结-16"><a href="#错题小结-16" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>数据在功能部件之间传送的路径被称为数据通路，包括数据通路上流经的部件，如程序计数器、ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号。因此不包括控制部件。</li>
</ol>
<h2 id="多处理器的基本概念"><a href="#多处理器的基本概念" class="headerlink" title="多处理器的基本概念"></a>多处理器的基本概念</h2><h3 id="SISD、SIMD、MIMD的基本概念"><a href="#SISD、SIMD、MIMD的基本概念" class="headerlink" title="SISD、SIMD、MIMD的基本概念"></a>SISD、SIMD、MIMD的基本概念</h3><ol>
<li><p>单指令流单数据流（SISD）结构</p>
</li>
<li><p>单指令流多数据流（SIMD）结构</p>
</li>
<li><p>多指令流单数据流（MISD）结构</p>
<p>实际上不存在</p>
</li>
<li><p>多指令流多数据流（MIMD）结构</p>
</li>
</ol>
<h3 id="硬件多线程的基本概念"><a href="#硬件多线程的基本概念" class="headerlink" title="硬件多线程的基本概念"></a>硬件多线程的基本概念</h3><p>为了减少线程切换过程中的开销，便诞生了硬件多线程。有3种实现方式：</p>
<ol>
<li>细粒度多线程</li>
<li>粗粒度多线程</li>
<li>同时多线程</li>
</ol>
<h3 id="多核处理器的基本概念"><a href="#多核处理器的基本概念" class="headerlink" title="多核处理器的基本概念"></a>多核处理器的基本概念</h3><h3 id="共享内存多处理器的基本概念"><a href="#共享内存多处理器的基本概念" class="headerlink" title="共享内存多处理器的基本概念"></a>共享内存多处理器的基本概念</h3><h3 id="错题小结-17"><a href="#错题小结-17" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>Flynn分类法将计算机体系结构分为SISD、SIMD、MISD、MIMD四类。常规的单处理器属于SISD，常规的多处理器属于MIMD。</li>
<li>含有超线程技术的CPU需要芯片组和操作系统的支持才能发挥技术优势。</li>
<li>双核CPU是空间并行的并行计算。</li>
<li>UMA框架需要解决的重要问题是Cache一致性，因为每个CPU核心都使用共享内存的一部分副本作为Cache。</li>
</ol>
<h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><h2 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h2><h3 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h3><p>随着计算机的发展和应用领域的不断扩大，I&#x2F;O 设备的种类和数量也越来越多。为了更好地解决 I&#x2F;O 设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。</p>
<p>总线是连接多个部件的信息传输线或通路，是负责各部件之间通信的传输介质。同一时刻只允许有一个部件向总线发送消息，但多个部件可以同时从总线上接收相同的消息。</p>
<p>总线上所连接的各类设备，按其对总线有无控制功能可分为主设备和从设备两种。</p>
<ul>
<li>主设备。指获得总线控制权的设备，也称主模块。</li>
<li>从设备：指被主设备访问的设备，只能响应主设备发来的各种总线命令，也称从模块。</li>
</ul>
<p>总线特性包括以下几项。</p>
<ul>
<li>机械特性。指总线在机械连接方式上的一些性能，如尺寸、形状与标准等。</li>
<li>电气特性。指总线的每一根传输线上信号的传输方向和有效的电平范围。</li>
<li>功能特性。指总线中每根传输线的功能。</li>
<li>时间特性。指总线中的任一根线在什么时间内有效。每条总线上的各种信号互相存在一种有效时序的关系。</li>
</ul>
<h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p>计算机系统中的总线，按功能划分为片内总线、系统总线、IO总线和通信总线四类。</p>
<h4 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h4><p>片内总线是指芯片内部的总线，它是 <code>CPU</code>芯片内部，寄存器与寄存器之间、寄存器与算术逻辑单元 <code>ALU</code>之间的公共连接线。</p>
<h4 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h4><p>系统总线是指 <code>CPU</code>、<code>主存</code>、<code>I/O 接口</code>各功能部件之间相互连接的信息传输线。按系统总线传输信息的不同，又可分为数据总线、地址总线和控制总线三类。</p>
<ol>
<li>数据总线用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关。</li>
<li>地址总线用来指出数据总线上的源数据或目的数据在主存单元的地址或 I&#x2F;O 端口的地址，它是单向传输总线，地址线的位数与存储单元的个数有关。</li>
<li>控制总线传输的是各种控制信息，包括 <code>CPU</code><br>送出的控制命令、主存或外设返回 <code>CPU</code><br>的反馈信号。</li>
</ol>
<blockquote>
<p>各个功能部件通过 <code>数据总线</code>连接形成的数据传输路径称为 <code>数据通路</code>。</p>
<p><code>数据通路</code>表示的是数据流经的路径，而<code>数据总线</code>是承载的媒介。</p>
</blockquote>
<h4 id="IO总线"><a href="#IO总线" class="headerlink" title="IO总线"></a>IO总线</h4><p>I&#x2F;O总线主要用于连接中低速的I&#x2F;O设备，通过I&#x2F;O接口与系统总线相连接，目的是将低速设备与高速总线分离，以提升总线的系统性能，常见的有USB、PCI总线。</p>
<h4 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h4><p>通信总线是在计算机系统之间或计算机系统与其他系统之间传送信息的总线，通信总线也称外部总线。按数据传输方式可分为串行通信和并行通信两种。</p>
<ul>
<li>串行通信是指数据在单条 1 位宽的传输线上，一位一位地按顺序分时传送。如在串行传送中，1 字节的数据要通过一条传输线分 8 次由低位到高位按顺序逐位传送。</li>
<li>并行通信是指数据在多条并行 1 位宽的传输线上，同时由源传送到目的地。如在并行传送中，1 字节的数据要通过 8 条并行传输线同时由源传送到目的地。</li>
</ul>
<h3 id="系统总线的结构"><a href="#系统总线的结构" class="headerlink" title="系统总线的结构"></a>系统总线的结构</h3><p>引入总线结构主要是为了</p>
<ul>
<li>简化系统结构，便于系统设计制造。</li>
<li>减少连接数目，便于布线，减小体积，提高系统可靠性。</li>
<li>便于接口设计，所有与总线连接的设备均采用类似的接口。</li>
<li>便于系统扩充、更新与灵活配置，易于实现系统模块化。</li>
<li>便于设备的软件设计，所有接口的软件就是对不同的口地址进行操作。</li>
<li>便于故障诊断和维修，同时也降低了成本。</li>
</ul>
<p>总线结构通常分为单总线结构和多总线结构两种。多总线结构分为双总线、三总线和四总线等等。</p>
<h4 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h4><p>单总线结构将 <code>CPU</code>、主存、通过 I&#x2F;O 接口的设备都挂在一组总线上，允许 I&#x2F;O 设备之间、I&#x2F;O 设备与 <code>CPU</code>之间或 I&#x2F;O 设备与主存之间直接交换信息，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/modb_20211227_5016ceb0-66c0-11ec-b728-fa163eb4f6be.png" alt="img"></p>
<p>优点是结构简单，成本低，易于接入新设备；缺点是带宽低、负载重，多个部件争用唯一总线，且不支持并发传送操作。</p>
<blockquote>
<p>单总线并不是指只有一根信号线，系统总线按传递信息的不同可细分为地址总线、数据总线和控制总线。</p>
</blockquote>
<h4 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h4><p>双总线结构有两条总线，一条是主存总线，用于在 <code>CPU</code>、主存和通道之间传送数据；另一条是 I&#x2F;O 总线，用于在多个外部设备与通道之间传送数据，如下图所示。</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211227_505c68d0-66c0-11ec-b728-fa163eb4f6be.png" alt="img"></p>
<p>优点是将低速的 I&#x2F;O 设备从单总线上分离出来，实现了主存总线与 I&#x2F;O 总线分离；缺点是需要增加通道等硬件设备。</p>
<blockquote>
<p>通道是一个具有特殊功能的处理器，<code>CPU</code><br>将一部分功能下放给通道，使其对 I&#x2F;O 设备具有统一管理的功能，以完成外部设备与主存储器之间的数据传送。</p>
</blockquote>
<h4 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h4><p>三总线结构是在计算机系统各部件之间采用三条各自独立的总线来构成信息通路，这三条总线分别为主存总线、I&#x2F;O 总线和DMA总线，如下图所示。</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211227_50721b58-66c0-11ec-b728-fa163eb4f6be.png" alt="img"></p>
<ul>
<li>主存总线。用于 <code>CPU</code><br>和主存之间传送地址、数据和控制信息。</li>
<li>I&#x2F;O 总线。用于在 <code>CPU</code><br>和各类 I&#x2F;O 设备之间通信。</li>
<li>DMA 总线。用于在主存和高速 I&#x2F;O 设备之间直接传送数据。</li>
</ul>
<p>优点是提高了 I&#x2F;O 设备的性能，使其更快地响应命令，提高了系统吞吐量；缺点是系统工作效率更低。</p>
<p>三总线结构中，任一时刻只能使用一种总线。主存总线与 DMA 总线不能同时对主存进行存取，I&#x2F;O 总线只有在 <code>CPU</code><br>执行 I&#x2F;O 指令时才能用到。</p>
<p>另一种三总线结构采用的是局部总线、系统总线和扩展总线，如下图所示。</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211227_50a84642-66c0-11ec-b728-fa163eb4f6be.png" alt="img"></p>
<ul>
<li>局部总线。用于在 <code>CPU</code>与 <code>Cache</code>之间直接通信，并将 <code>CPU</code>与 <code>Cache</code>或与更多的局部设备相连。</li>
<li>系统总线。用于在主存与 <code>Cache</code>之间传输信息，I&#x2F;O 设备与主存之间的传输不必通过 <code>CPU</code>。</li>
<li>扩展总线。将局域网、小型计算机接口 <code>SCSI</code>、调制解调器 <code>Modem</code>以及串行接口等都连接起来，并通过这些接口又可与各类 I&#x2F;O 设备相连，可支持相当多的 I&#x2F;O 设备。扩展总线通过扩展总线接口可与系统总线相连，实现这两种总线之间的信息传递，提高工作效率。</li>
</ul>
<h3 id="常见的总线标准"><a href="#常见的总线标准" class="headerlink" title="常见的总线标准"></a>常见的总线标准</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230712211414179.png" alt="image-20230712211414179"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230712211421722.png" alt="image-20230712211421722"></p>
<h3 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h3><ol>
<li>总线的传输周期。指一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段），简称总线周期。总线传输周期通常由若干总线时钟周期构成。</li>
<li>总线时钟周期。即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。</li>
<li>总线的工作效率。总线上各种操作的频率，为总线周期的倒数。实际上指 1 秒内传送几次数据。若总线周期 &#x3D; N 个时钟周期，则总线的工作频率 &#x3D; 时钟频率&#x2F;N。</li>
<li>总线的时钟频率。即机器的时钟频率，它为时钟周期的倒数。</li>
<li>总线宽度。又称总线位宽，它是总线上同时能够传输的数据位数，通常指数据总线的根数，如 32 根称为 32 位总线。</li>
<li>总线带宽。可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节&#x2F;秒（B&#x2F;s）表示。总线带宽 &#x3D; 总线工作频率×(总线宽度&#x2F;8)。</li>
<li>总线复用。总线复用是指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息，从而节省空间和成本。</li>
<li>信号线数。地址总线、数据总线和控制总线 3 种总线数的总和称为信号线数。其中，总线的最主要性能指标为总线宽度、总线（工作）频率、总线带宽，总线带宽是指总线本身所能达到的最高传输速率，它是衡量总线性能的重要指标。</li>
</ol>
<blockquote>
<p>三者关系：总线带宽 &#x3D; 总线宽度×总线频率。</p>
<p>例如，总线工作频率为 22MHz，总线宽度为 16 位，则总线带宽 &#x3D; 22×(16&#x2F;8)&#x3D;44。</p>
</blockquote>
<h3 id="错题小结-18"><a href="#错题小结-18" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>挂接在总线上的多个部件，只能分时向总线发送数据，但可同时向总线接收数据。</li>
<li>在总线上，同一时刻只能有一个主设备控制总线传输操作。</li>
<li>系统总线用来连接CPU、主存和外设部件。</li>
<li>在现代微机主板上，采用局部总线技术的作用是节省系统的总带宽。</li>
<li>并行总线传输不一定比串行总线传输快。</li>
</ol>
<h2 id="总线事务和定时"><a href="#总线事务和定时" class="headerlink" title="总线事务和定时"></a>总线事务和定时</h2><p>总线定时：总线在双方交换数据的过程中需要时间上配合关系的控制。（实质是一种协议或者规则）</p>
<p>总线事务：从请求总线到完成总线使用的操作序列。（在一个总线周期中发生的一系列活动）</p>
<h3 id="1-总线事务"><a href="#1-总线事务" class="headerlink" title="1.总线事务"></a>1.总线事务</h3><ol>
<li>请求阶段：主设备发出总线传输请求并且获得总线控制权。</li>
<li>仲裁阶段：总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者。</li>
<li>寻址阶段：主设备通过总线给出要访问的从设备地址及有关命令，启动从模块。</li>
<li>传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送。（一般只能传输一个字长的数据）</li>
<li>释放阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权。</li>
</ol>
<p>突发传送方式能够进行连续成组数据的传送，其寻址阶段发送的是连续数据单元的首地址，在传输阶段传送多个连续单元的数据，每个时钟周期可以传送一个字长的信息，但是不释放总线，直到一组数据全部传送完毕后，再释放总线。</p>
<h3 id="2-同步定时方式"><a href="#2-同步定时方式" class="headerlink" title="2.同步定时方式"></a>2.同步定时方式</h3><p>系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。</p>
<p>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单</p>
<p>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性验证，可靠性较差</p>
<p>适用于总线长度较短及总线所接部件的存储时间比较接近的系统。</p>
<h3 id="3-异步定时方式"><a href="#3-异步定时方式" class="headerlink" title="3.异步定时方式"></a>3.异步定时方式</h3><p>没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。</p>
<p>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。</p>
<p>缺点：比同步稍复杂一些，速度比同步方式慢。</p>
<h4 id="1）不互锁方式"><a href="#1）不互锁方式" class="headerlink" title="1）不互锁方式"></a>1）不互锁方式</h4><p>主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是过一段时间便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并过一段时间便撤销“回答”信号。</p>
<h4 id="2）半互锁方式"><a href="#2）半互锁方式" class="headerlink" title="2）半互锁方式"></a>2）半互锁方式</h4><p><em>主设备发出“请求”信号后，必须等到接到从设备的“回答”信号，才能撤销“请求”信号。（互锁关系）</em>而从设备在接到“请求”信号后，发出“回答”信号，但不必等到获知主设备的“请求”信号已经撤销，而是过一段时间便撤销“回答”信号。</p>
<h4 id="3）全互锁方式"><a href="#3）全互锁方式" class="headerlink" title="3）全互锁方式"></a>3）全互锁方式</h4><p><em>主设备发出“请求”信号后，必须等到接到从设备的“回答”信号，才能撤销“请求”信号。（互锁关系）而从设备在接到“请求”信号后，发出“回答”信号，必需等到获知主设备的“请求”信号已经撤销，才能撤销“回答”信号。</em></p>
<h4 id="请求和回答信号的互锁"><a href="#请求和回答信号的互锁" class="headerlink" title="请求和回答信号的互锁"></a>请求和回答信号的互锁</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/v2-8cd4dbbab040e9c5d43f9bca2b3d2278_720w.webp" alt="img"></p>
<h3 id="错题小结-19"><a href="#错题小结-19" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>在异步总线中，传送操作按需分配时间</li>
<li>总线的异步通信方式是不采用时钟信号，只采用“握手”信号。</li>
<li>同步总线由时钟信号定时，但时钟频率不一定等于工作频率，因为一个事务不一定在一个时钟周期内完成。</li>
</ol>
<h1 id="输入-输出系统"><a href="#输入-输出系统" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h1><h2 id="IO系统基本概念"><a href="#IO系统基本概念" class="headerlink" title="IO系统基本概念"></a>IO系统基本概念</h2><h3 id="输入-输出系统-1"><a href="#输入-输出系统-1" class="headerlink" title="输入&#x2F;输出系统"></a>输入&#x2F;输出系统</h3><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230713002400499.png" alt="image-20230713002400499"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230713002424307.png" alt="image-20230713002424307"></p>
<h3 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230713002612263.png" alt="image-20230713002612263"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230713002629423.png" alt="image-20230713002629423"></p>
<h3 id="错题小结-20"><a href="#错题小结-20" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>I&#x2F;O设备通过设备控制器于主板的系统总线相连接</li>
<li>通道程序存放在主存而非通道中，由通道从主存中取出并执行。通道程序有通道执行，且只能在具有通道的I&#x2F;O系统中执行。</li>
<li>打字机从打字原理的角度来分，可分为击打式和非击打式两种；从能否打出汉字来分，可分为点阵式打字机和活字式打字机。</li>
</ol>
<h2 id="I-O-接口"><a href="#I-O-接口" class="headerlink" title="I&#x2F;O 接口"></a>I&#x2F;O 接口</h2><p>I&#x2F;O 接口，又称 I&#x2F;O 控制器，是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。主机和外设具有各自的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了解决这些差异而设置的。</p>
<h3 id="I-O-接口功能"><a href="#I-O-接口功能" class="headerlink" title="I&#x2F;O 接口功能"></a>I&#x2F;O 接口功能</h3><p>I&#x2F;O 接口的主要功能如下：</p>
<ol>
<li>实现主机和外设的通信联络控制。解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。</li>
<li>进行地址译码和设备选择。<code>CPU</code>送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息。</li>
<li>实现数据缓冲。<code>CPU</code>与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。</li>
<li>信号格式的转换。外设与主机两者的电平、数据格式都可能存在差异，接口应提供计算机与外设的信号格式的转换功能，如电平转换、<code>并/串</code>或<code>串/并</code>转换、<code>模/数</code>或<code>数/模</code>转换等。</li>
<li>传送控制命令和状态信息。<code>CPU</code>要启动某一外设时，通过接口中的命令寄存器向外设发出启动命令；外设准备就绪时，则将<code>准备好</code>状态信息送回接口中的状态寄存器，并反馈给 CPU。外设向 <code>CPU</code>提出中断请求和 <code>DMA</code>请求时，<code>CPU</code>也应有相应的响应信号反馈给外设。</li>
</ol>
<h3 id="I-O-接口结构"><a href="#I-O-接口结构" class="headerlink" title="I&#x2F;O 接口结构"></a>I&#x2F;O 接口结构</h3><p>为使 I&#x2F;O 接口实现基本功能，需要具有相应的逻辑电路，基本结构如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/modb_20211227_51decc3e-66c0-11ec-b728-fa163eb4f6be.png" alt="img"></p>
<p><code>CPU</code>与外设之间的信息传送，实质上是对接口中的某些寄存器（即端口）进行读或写，如传送数据是对数据端口 <code>DBR</code><br>进行读写操作。</p>
<ul>
<li>内部接口：内部接口与系统总线相连，实质上是与内存、<code>CPU</code>相连。数据的传输方式只能是并行传输。</li>
<li>外部接口：外部接口通过接口电缆与外设相连，外部接口的数据传输可能是串行方式，因此 I&#x2F;O 接口需具有<code>串/并</code><br>转换功能。</li>
</ul>
<blockquote>
<p>接口和端口不相同，端口是指接口电路中可以进行读&#x2F;写的寄存器，若干端口加上相应的控制逻辑才可以组成接口。</p>
</blockquote>
<h3 id="I-O-接口类型"><a href="#I-O-接口类型" class="headerlink" title="I&#x2F;O 接口类型"></a>I&#x2F;O 接口类型</h3><p>从不同的角度看，I&#x2F;O 接口可以分为不同的类型。</p>
<ul>
<li>按数据传送方式可分为并行接口和串行接口，接口要完成数据格式的转换。并行接口是将一个字节或一个字的所有位同时传送；串行接口是在设备与接口间一位一位传送。</li>
<li>按主机访问 I&#x2F;O 设备的控制方式可分为程序查询接口、中断接口和 DMA 接口等。</li>
<li>按功能选择的灵活性可分为可编程接口和不可编程接口。</li>
</ul>
<blockquote>
<p>数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。</p>
</blockquote>
<h3 id="I-O-端口"><a href="#I-O-端口" class="headerlink" title="I&#x2F;O 端口"></a>I&#x2F;O 端口</h3><p>I&#x2F;O 端口是指接口电路中可被 <code>CPU</code>直接访问的寄存器，主要有数据端口、状态端口和控制端口，若干端口加上相应的控制逻辑电路组成接口。通常，<code>CPU</code>能对数据端口执行读写操作，但对状态端口只能执行读操作，对控制端口只能执行写操作。</p>
<p>I&#x2F;O 端口要想能够被 <code>CPU</code>访问，必须要有端口地址，每个端口对应一个端口地址。而对 I&#x2F;O 端口的编址方式有与存储器统一编址和独立编址两种。</p>
<h3 id="统一编址"><a href="#统一编址" class="headerlink" title="统一编址"></a>统一编址</h3><p>统一编址，又称存储器映射方式，是指把 I&#x2F;O 端口当作存储器的单元进行地址分配，这种方式 <code>CPU</code>不需要设置专门的 I&#x2F;O 指令，用统一的访存指令就可以访问 I&#x2F;O 端口。</p>
<p>该编址方式的优点是不需要设置专门的输入&#x2F;输出指令，可使 <code>CPU</code>访问 I&#x2F;O 的操作更灵活、更方便，还可使端口有较大的编址空间。而其缺点是端口占用存储器地址，使内存容量变小，而且利用存储器编址的 I&#x2F;O 设备进行数据输入&#x2F;输出操作，执行速度较慢。</p>
<h3 id="独立编址"><a href="#独立编址" class="headerlink" title="独立编址"></a>独立编址</h3><p>独立编址，又称 I&#x2F;O 映射方式，是指 I&#x2F;O 端口地址与存储器地址无关，独立编址 <code>CPU</code>需要设置专门的输入&#x2F;输出指令访问端口。</p>
<p>独立编址的优点是 I&#x2F;O 指令与存储器指令有明显区别，程序编制清晰，便于理解。其缺点是 I&#x2F;O 指令少，一般只能对端口进行传送操作，尤其需要 <code>CPU</code>提供存储器读&#x2F;写、I&#x2F;O 设备读&#x2F;写两组控制信号，增加了控制的复杂性。</p>
<h3 id="错题小结-21"><a href="#错题小结-21" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li>磁盘驱动器向盘片磁道记录数据时采用串行方式写入。</li>
<li>I&#x2F;O指令实现的数据传送通常发生在CPU寄存器和I&#x2F;O端口之间。</li>
</ol>
<h2 id="I-O方式"><a href="#I-O方式" class="headerlink" title="I&#x2F;O方式"></a>I&#x2F;O方式</h2><h3 id="错题小结-22"><a href="#错题小结-22" class="headerlink" title="错题小结"></a>错题小结</h3><ol>
<li><p>外部事件如Esc键退出运行的程序等，属于外中断。</p>
</li>
<li><p>Cache完全是由硬件实现的，不会涉及中断层面。</p>
</li>
<li><p>虚拟存储器失效如缺页等，会发出缺页中断，属于内中断。</p>
</li>
<li><p>浮点数运算下溢，直接当作机器零处理，不会引发中断。</p>
</li>
<li><p>浮点数运算上溢，表示超过了浮点数的表示范围，属于内中断。</p>
</li>
<li><p>中断服务程序的最后指令是中断返回指令而不是无条件转移指令。中断返回指令与无条件转移指令不同的是，它不仅要修改PC值，而且要将CPU中的所有寄存器都恢复到中断前的状态。</p>
</li>
<li><p>关于中断的分类和优先级</p>
<p>1.机器校验中断：高速程序发生了设备故障，比如电源故障，主存出错等</p>
<p>2.访管中断：用户程序需要操作系统接入，调用操作系统服务等</p>
<p>3.程序性中断：包括指令和数据的格式错误，程序执行中出现异常等</p>
<p>4.外部中断：来自机器外部，包括定时器中断、外部信号中断、中断键中断等</p>
<p>5.IO中断：由IO控制器产生，用于发送信号通知操作完成</p>
<p>6.重启中断</p>
</li>
<li><p>设置中断屏蔽标志可以概念多个中断服务程序执行完毕的顺序（执行顺序）。</p>
</li>
<li><p>DMA的数据传送不经过CPU，但需要经过DMA控制器中的数据缓冲寄存器（DMAC）。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/Computer%20composition%20principle/" data-id="clqwhy493000pikvfg5764ost" data-title="Computer composition principle" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-composition-principle/" rel="tag">Computer composition principle</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/algorithm/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:49.429Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/02/algorithm/">algorithm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">           <span class="type">int</span> pivot = A[low];</span><br><span class="line">           <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">               <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)&#123;</span><br><span class="line">                   high--;</span><br><span class="line">               &#125;</span><br><span class="line">               A[low] = A[high];</span><br><span class="line">               <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)&#123;</span><br><span class="line">                   low++;</span><br><span class="line">               &#125;</span><br><span class="line">               A[low] = A[high];</span><br><span class="line">           &#125;</span><br><span class="line">           A[low] = pivot;</span><br><span class="line">           <span class="keyword">return</span> low;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">               <span class="type">int</span> pivotpos = <span class="built_in">partition</span>(nums,low,high);</span><br><span class="line">               <span class="built_in">quicksort</span>(nums,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">               <span class="built_in">quicksort</span>(nums,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/algorithm/" data-id="clqwhy48v000nikvf72ckgbjd" data-title="algorithm" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-typescript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/typescript/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:49.424Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/02/typescript/">typescript</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-基础类型"><a href="#1-基础类型" class="headerlink" title="1. 基础类型"></a>1. 基础类型</h1><p><code>TypeScript</code> 支持与 <code>JavaScript</code> 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<p>1.布尔值</p>
<p>最基本的数据类型就是简单的 true&#x2F;false 值，在<code>JavaScript</code> 和 <code>TypeScript</code> 里叫做 <code>boolean</code>（其它语言中也一样）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">isDone = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// isDone = 2 // error</span></span><br></pre></td></tr></table></figure>

<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>和<code> JavaScript</code> 一样，<code>TypeScript </code>里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，<code>TypeScript</code> 还支持 <code>ECMAScript</code> 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a1</span>: <span class="built_in">number</span> = <span class="number">10</span> <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>  <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a3</span>: <span class="built_in">number</span> = <span class="number">0o12</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a4</span>: <span class="built_in">number</span> = <span class="number">0xa</span> <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>:<span class="built_in">string</span> = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"><span class="comment">// name = 12 // error</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span>, I am <span class="subst">$&#123;age&#125;</span> years old!`</span></span><br></pre></td></tr></table></figure>

<h2 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h2><p><code>TypeScript</code> 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 它们的本身的类型用处不是很大：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>TypeScript</code> 像<code> JavaScript</code> 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h2><p>元组类型允许表示一个已知元素数量和类型的数组，<code>各元素的类型不必相同</code>。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">t1</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">t1 = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line">t1 = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>] <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t1[<span class="number">0</span>].<span class="title function_">substring</span>(<span class="number">1</span>)) <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t1[<span class="number">1</span>].<span class="title function_">substring</span>(<span class="number">1</span>)) <span class="comment">// Error, &#x27;number&#x27; 不存在 &#x27;substring&#x27; 方法</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以<code>为一组数值赋予友好的名字</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举数值默认从0开始依次递增</span></span><br><span class="line"><span class="comment">// 根据特定的名称得到对应的枚举数值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myColor</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myColor, <span class="title class_">Color</span>.<span class="property">Red</span>, <span class="title class_">Color</span>.<span class="property">Blue</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span></span><br></pre></td></tr></table></figure>

<p>或者，全部都采用手动赋值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span> = <span class="number">2</span>, <span class="title class_">Blue</span> = <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span></span><br></pre></td></tr></table></figure>

<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName)  <span class="comment">// &#x27;Green&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">&#x27;maybe a string&#x27;</span></span><br><span class="line">notSure = <span class="literal">false</span> <span class="comment">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>

<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它<code>表示没有任何类型</code>。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn()&#x27;</span>)</span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line">  <span class="comment">// return 1 // error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>之外的类型。</p>
<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">obj:<span class="built_in">object</span></span>):<span class="built_in">object</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2()&#x27;</span>, obj)</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn2</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>)))</span><br><span class="line"><span class="comment">// console.log(fn2(&#x27;abc&#x27;) // error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn2</span>(<span class="title class_">String</span>))</span><br></pre></td></tr></table></figure>

<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString2</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) : <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求2: 定义一个一个函数得到一个数字或字符串值的长度</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>):<span class="built_in">number</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return x.length // error</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="property">length</span>) &#123; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> x.<span class="property">length</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。<code>TypeScript</code>会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法, 另一个为 <code>as</code> 语法</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类型断言(Type Assertion): 可以用来手动指定一个值的类型</span></span><br><span class="line"><span class="comment">语法:</span></span><br><span class="line"><span class="comment">    方式一: &lt;类型&gt;值</span></span><br><span class="line"><span class="comment">    方式二: 值 as 类型  tsx中只能用这种方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;x).<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(<span class="string">&#x27;abcd&#x27;</span>), <span class="title function_">getLength</span>(<span class="number">1234</span>))</span><br></pre></td></tr></table></figure>

<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>类型推断: TS会在没有明确的指定类型的时候推测出一个类型<br>有下面2种情况: 1. 定义变量时赋值了, 推断为对应的类型. 2. 定义变量时没有赋值, 推断为any类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义变量时赋值了, 推断为对应的类型 */</span></span><br><span class="line"><span class="keyword">let</span> b9 = <span class="number">123</span> <span class="comment">// number</span></span><br><span class="line"><span class="comment">// b9 = &#x27;abc&#x27; // error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义变量时没有赋值, 推断为any类型 */</span></span><br><span class="line"><span class="keyword">let</span> b10  <span class="comment">// any类型</span></span><br><span class="line">b10 = <span class="number">123</span></span><br><span class="line">b10 = <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h1><p><code>TypeScript</code> 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。<code>接口是对象的状态(属性)和行为(方法)的抽象(描述)</code></p>
<h2 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h2><p>需求: 创建人的对象, 需要对人的属性进行一定的约束</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id是number类型, 必须有, 只读的</span><br><span class="line">name是string类型, 必须有</span><br><span class="line">age是number类型, 必须有</span><br><span class="line">sex是string类型, 可以没有</span><br></pre></td></tr></table></figure>

<p>下面通过一个简单示例来观察接口是如何工作的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型</span></span><br><span class="line"><span class="comment">接口: 是对象的状态(属性)和行为(方法)的抽象(描述)</span></span><br><span class="line"><span class="comment">接口类型的对象</span></span><br><span class="line"><span class="comment">    多了或者少了属性是不允许的</span></span><br><span class="line"><span class="comment">    可选属性: ?</span></span><br><span class="line"><span class="comment">    只读属性: readonly</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">需求: 创建人的对象, 需要对人的属性进行一定的约束</span></span><br><span class="line"><span class="comment">  id是number类型, 必须有, 只读的</span></span><br><span class="line"><span class="comment">  name是string类型, 必须有</span></span><br><span class="line"><span class="comment">  age是number类型, 必须有</span></span><br><span class="line"><span class="comment">  sex是string类型, 可以没有</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义人的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person1</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型检查器会查看对象内部的属性是否与<code>IPerson</code>接口描述一致, 如果不一致就会提示类型错误。</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  sex?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// sex: &#x27;男&#x27; // 可以没有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code> 来指定只读属性:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  sex?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦赋值后再也不能被改变了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// sex: &#x27;男&#x27; // 可以没有</span></span><br><span class="line">  <span class="comment">// xxx: 12 // error 没有在接口中定义, 不能有</span></span><br><span class="line">&#125;</span><br><span class="line">person2.<span class="property">id</span> = <span class="number">2</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h3 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a><code>readonly</code> vs <code>const</code></h3><p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用 <code>readonly</code>。</p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">接口可以描述函数类型(参数的类型与返回的类型)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span> = <span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> source.<span class="title function_">search</span>(sub) &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mySearch</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h3><p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类类型: 实现接口</span></span><br><span class="line"><span class="comment">1. 一个类可以实现多个接口</span></span><br><span class="line"><span class="comment">2. 一个接口可以继承多个接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">  <span class="title function_">lightOn</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">lightOff</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个类可以实现多个接口"><a href="#一个类可以实现多个接口" class="headerlink" title="一个类可以实现多个接口"></a>一个类可以实现多个接口</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car2</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span>, <span class="title class_">Light</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">lightOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car light on&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">lightOff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car light off&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h2><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LightableAlarm</span> <span class="keyword">extends</span> <span class="title class_">Alarm</span>, <span class="title class_">Light</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/typescript/" data-id="clqwhy48f000jikvfbdugc1wa" data-title="typescript" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-os" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/os/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:49.417Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/02/os/">os</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/os/" data-id="clqwhy47v000bikvfcyzf9031" data-title="os" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/os/" rel="tag">os</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-npm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/npm/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:49.412Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>官网：<a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com</a></p>
<h5 id="NPM的使用"><a href="#NPM的使用" class="headerlink" title="NPM的使用"></a>NPM的使用</h5><ol>
<li><p>查看npm版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用npm命令安装模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;module name&gt;</span><br><span class="line"></span><br><span class="line">npm install &lt;module name&gt; -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm list -g  //查看所有全局安装的模块</span><br><span class="line"></span><br><span class="line">npm list &lt;module name&gt;  //查看某个模块的版本号</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新至某个特定版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;module name&gt;@版本号</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定模块是运行及发布后都需要的模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -save moduleName</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定模块只在开发时需要，发布时不需要用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -save-dev moduleName</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="Yarn的使用"><a href="#Yarn的使用" class="headerlink" title="Yarn的使用"></a>Yarn的使用</h5><ol>
<li><p>新建一个包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装包</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yarn install //安装package.json里所有包，并将包以及他的所有依赖项保存进yarn.lock</span><br><span class="line">yarn install --flat //强制安装一个包的单一版本</span><br><span class="line">yarn install --force //强制重新下载所有包</span><br><span class="line">yarn instal --production //只安装depedencies里的包</span><br><span class="line">yarn install --no-lockfile //不读取或生成yarn.lock</span><br><span class="line">yarn install --pure-lockfile //不生成yarn.lock</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加包</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yarn add &lt;package&gt; //在当前项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中</span><br><span class="line">yarn add &lt;package&gt;@&lt;version&gt; //安装指定版本，如果需要精确到小版本，使用-E参数</span><br><span class="line">yarn add &lt;package&gt;@&lt;tag&gt; //安装某个tag</span><br><span class="line">yarn add --dev/-D //加到devDependencies</span><br><span class="line">yarn add --peer/-P //加到peerDependencies</span><br><span class="line">yarn add --optional/-O //加到optionalDependencies</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>移除包</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn remove &lt;package&gt;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>更新包</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn upgrade</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/npm/" data-id="clqwhy480000dikvf7i77c50z" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-math" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/math/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:49.407Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/02/math/">Math</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="高数笔记"><a href="#高数笔记" class="headerlink" title="高数笔记"></a>高数笔记</h1><h2 id="1-常见泰勒展开"><a href="#1-常见泰勒展开" class="headerlink" title="1.常见泰勒展开"></a>1.常见泰勒展开</h2><p>指数函数泰勒级数展开式</p>
<p><img src="https://pic2.zhimg.com/v2-c5641fe2ed117b1aad374162c8fa4131_b.jpg" alt="动图封面"></p>
<p>双曲函数泰勒级数展开式</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/v2-abc86a01c13f583754997e1a40259976_b.jpg" alt="动图封面"></p>
<p>三角函数泰勒级数展开式(公式)</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/v2-af016ea06bf01de04d78f06a7f5c54be_b.jpg" alt="动图封面"></p>
<p>反三角函数泰勒级数展开式</p>
<p><img src="https://pic2.zhimg.com/v2-70f2e5b2c04e24dc3a12a15753c9bcb1_b.webp" alt="动图"></p>
<p>对数函数泰勒级数展开式</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/v2-df5a17ab6b4b5a0d99ff0d1540e80f2b_b.jpg" alt="动图封面"></p>
<h2 id="2-积分基本公式"><a href="#2-积分基本公式" class="headerlink" title="2. 积分基本公式"></a>2. 积分基本公式</h2><h3 id="【1】基本积分表"><a href="#【1】基本积分表" class="headerlink" title="【1】基本积分表"></a>【1】基本积分表</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/v2-0855b8f2b620f94422d4e0c419cb0e58_720w.webp" alt="img"></p>
<h3 id="【2】常用积分公式"><a href="#【2】常用积分公式" class="headerlink" title="【2】常用积分公式"></a>【2】常用积分公式</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/v2-997b1a2db6748766b3fc840150b82635_720w.webp" alt="img"></p>
<h2 id="3-定积分的应用"><a href="#3-定积分的应用" class="headerlink" title="3.定积分的应用"></a>3.定积分的应用</h2><h3 id="1-平面图形的面积"><a href="#1-平面图形的面积" class="headerlink" title="1.平面图形的面积"></a>1.平面图形的面积</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230419172850798.png" alt="image-20230419172850798"></p>
<h3 id="2-旋转体体积"><a href="#2-旋转体体积" class="headerlink" title="2. 旋转体体积"></a>2. 旋转体体积</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230419172916366.png" alt="image-20230419172916366"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230419172907564.png" alt="image-20230419172907564"></p>
<h3 id="3-曲线弧长"><a href="#3-曲线弧长" class="headerlink" title="3. 曲线弧长"></a>3. 曲线弧长</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230419172933245.png" alt="image-20230419172933245"></p>
<h3 id="4-旋转体侧面积"><a href="#4-旋转体侧面积" class="headerlink" title="4. 旋转体侧面积"></a>4. 旋转体侧面积</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230419173001757.png" alt="image-20230419173001757"></p>
<h2 id="4-常微分方程"><a href="#4-常微分方程" class="headerlink" title="4. 常微分方程"></a>4. 常微分方程</h2><h3 id="1-可分离变量的方程"><a href="#1-可分离变量的方程" class="headerlink" title="1. 可分离变量的方程"></a>1. 可分离变量的方程</h3><p>可表示为形如<br>$$<br>g(y)dy &#x3D; f(x)dx<br>$$<br>的方程，称为可分离变量的方程，求解的方法是两端积分<br>$$<br>\int g(y)dy &#x3D; \int f(x)dx<br>$$</p>
<h3 id="2-齐次微分方程"><a href="#2-齐次微分方程" class="headerlink" title="2. 齐次微分方程"></a>2. 齐次微分方程</h3><p>能化为<br>$$<br>dy&#x2F;dx &#x3D; \phi(y&#x2F;x)<br>$$<br>的微分方程称为齐次微分方程。</p>
<p>求解齐次微分方程的一般方法：令u &#x3D; y&#x2F;x， 则y ‘  &#x3D; u + xu’ ，从而将原方程化为<br>$$<br>xu’ &#x3D; \phi(u) -u<br>$$<br>此方程为可分离变量的方程</p>
<h3 id="3-一阶线性微分方程"><a href="#3-一阶线性微分方程" class="headerlink" title="3. 一阶线性微分方程"></a>3. 一阶线性微分方程</h3><p>形如 y’ + p(x)y &#x3D; q(x) 的方程称为一阶线性微分方程</p>
<p>求解一阶线性微分方程的一般方法：常数变易法，或直接利用以下通解公式<br>$$<br>y &#x3D; e^{-\int p(x)dx}[\int q(x)e^{\int p(x)dx}dx + C]<br>$$</p>
<h3 id="4-可降阶的高阶方程"><a href="#4-可降阶的高阶方程" class="headerlink" title="4. 可降阶的高阶方程"></a>4. 可降阶的高阶方程</h3><p>三种类型的高阶方程<br>$$<br>y^{(n)} &#x3D; f(x)<br>$$</p>
<p>$$<br>y’’ &#x3D; f(x, y’)<br>$$</p>
<p>$$<br>y’’ &#x3D; f(y,y’)<br>$$</p>
<h3 id="5-高阶线性微分方程"><a href="#5-高阶线性微分方程" class="headerlink" title="5. 高阶线性微分方程"></a>5. 高阶线性微分方程</h3><h4 id="1-线性微分方程的解的结构"><a href="#1-线性微分方程的解的结构" class="headerlink" title="1. 线性微分方程的解的结构"></a>1. 线性微分方程的解的结构</h4><p>这里只讨论二阶线性微分方程，其结论可推广到更高阶的方程，二阶线性微分方程的一般形式为：<br>$$<br>y’’ +p(x)y’ + q(x)y &#x3D; f(x)<br>$$<br>这里的p(x), q(x), f(x)均为连续函数，当方程右端的f(x) 为0时，称为二阶线性齐次方程，否则称为二阶线性非齐次方程</p>
<p>齐次方程<br>$$<br>y’’ +p(x)y’ + q(x)y &#x3D; 0<br>$$<br>非齐次方程<br>$$<br>y’’ +p(x)y’ + q(x)y &#x3D; f(x)<br>$$</p>
<blockquote>
<p>定理：</p>
</blockquote>
<ol>
<li><p>若y1(x)和y2(x)是齐次方程的的两个线性无关的特解，那么<br>$$<br>y &#x3D; C_1y_1(x) + C_2y_2(x)<br>$$<br>就是该齐次方程的通解</p>
</li>
<li><p>若y<em>是非齐次方程的一个特解，y1(x)和y2(x)是齐次方程的的两个线性无关的特解，则<br>$$<br>y &#x3D; C_1y_1(x) + C_2y_2(x) + y^</em>(x)<br>$$<br>是非齐次微分方程的通解</p>
</li>
<li><p>如果y1*(x), y2*(x)是非齐次方程的两个特解，则<br>$$<br>y(x) &#x3D; y_2^*(x) - y_1^*(x)<br>$$<br>是齐次微分方程的解</p>
</li>
<li><p>如果如果y1*(x), y2*(x)分别是<br>$$<br>y’’ +p(x)y’ + q(x)y &#x3D; f_1(x)\<br>y’’ +p(x)y’ + q(x)y &#x3D; f_2(x)<br>$$<br>的特解，则y1*(x) + y2*(x)是方程<br>$$<br>y’’ +p(x)y’ + q(x)y &#x3D; f_1(x) + f_2(x)<br>$$<br>的一个特解</p>
</li>
</ol>
<h4 id="2-常系数齐次线性微分方程"><a href="#2-常系数齐次线性微分方程" class="headerlink" title="2. 常系数齐次线性微分方程"></a>2. 常系数齐次线性微分方程</h4><p>二阶常系数线性齐次微分方程的一般形式为<br>$$<br>y’’ + py’ + qy &#x3D; 0<br>$$<br>其特征方程为<br>$$<br>r^2 + pr + q &#x3D; 0<br>$$<br>设r$_1$, r$_2$为该方程的两个根</p>
<ol>
<li><p>若r$_1$，r$_2$为两个不想等的实特征根，则方程的通解为<br>$$<br>y &#x3D; C_1e^{r_1x}+C_2e^{r_2x}<br>$$</p>
</li>
<li><p>若r$_1$ &#x3D; r$_2$为二重实特征根，则方程的通解为<br>$$<br>y &#x3D; (C_1+C_2x)e^{r_1x}<br>$$</p>
</li>
<li><p>若$r_1 &#x3D;\alpha + i\beta$ ，$ r_2 &#x3D; \alpha - i\beta$为一对共轭复根，则方程的通解为<br>$$<br>y &#x3D; e^{\alpha x}(C_1cos\beta x+C_2sin\beta x)<br>$$</p>
</li>
</ol>
<h2 id="5-函数、极限、连续"><a href="#5-函数、极限、连续" class="headerlink" title="5.函数、极限、连续"></a>5.函数、极限、连续</h2><ol>
<li><p>f’(x)有界，则f(x)有界</p>
</li>
<li><p>f’(x<del>0</del>)&gt;0，得不到一定存在x<del>0</del>的某邻域，在此邻域内f(x)单调增，反例如下：<br>$$<br>f(x) &#x3D;<br>\begin{cases}<br>x + 2x^2sin(\frac{1}{x}),x\neq 0 \<br>0, x &#x3D; 0<br>\end{cases}<br>\<br>$$</p>
</li>
</ol>
<p>此时在x&#x3D;0的任何邻域内都存在导数为负的点，从而f(x)在x &#x3D; 0的任何邻域内都不单调增</p>
<ol start="3">
<li><p>函数在x<del>0</del>点的极限值是否存在仅与函数在x<del>0</del>的去心邻域内的函数值无关，与函数是否在该点有无定义无关</p>
</li>
<li><p>需要求左右极限的情况：</p>
<ol>
<li>分段函数分界点的极限</li>
<li>e$^{\infty}$型极限</li>
<li>$arctan\infty$型极限</li>
</ol>
</li>
<li><p>极限的局部有界性：</p>
<p>某一点极限存在，在这一点的某去心邻域有界。反之，函数在某点的某去心邻域有界，不可推出该点极限存在，反例为$sin\frac{1}{x}$</p>
</li>
<li><p>极限的保号性：</p>
<p>极限大于0，函数值大于0（极限值报函数值）</p>
<p>函数值大于等于0，极限大于等于0（函数值保极限值）</p>
<p>相应地，可推出保序性。</p>
</li>
<li><p>求解n项和的极限，多用夹逼准则；求解递推公式，多用单调有界准则。</p>
</li>
<li><p>常用不等式：<br>$$<br>tanx &lt; x &lt; sinx, x\in (0, \Pi &#x2F;2)\<br>\frac{x}{1+x} &lt; ln(1+x) &lt; x, x\in(0,+\infty)\<br>ln^\alpha x \ll x^\beta \ll a^x, x\rightarrow +\infty\<br>ln^\alpha n \ll n^\beta \ll a^n \ll n! \ll n^n, n \rightarrow \infty(其中\alpha &gt;0,\beta &gt;0,a&gt;1)<br>$$</p>
</li>
<li><p>无穷大量和无界变量的关系</p>
</li>
<li><p>$n\rightarrow \infty,a_n &#x3D; a，那么|a_n| &#x3D; |a|$，但反之不成立；</p>
<p>$n\rightarrow \infty,a_n &#x3D; 0的充要条件是|a_n| &#x3D; 0$</p>
</li>
<li><p>注意洛必达法则使用的三个要求</p>
</li>
<li><p>求解极限时，若分子或分母不可使用加减法则，考虑提取公因子或使用拉格朗日定理进而求解，若分子拆开后各部分的极限仍然存在则将其拆开后求解极限，此时并不违反无穷小的加减代换法则。</p>
</li>
<li><p>利用单调有界准则求极限，先证有界，再证单调</p>
</li>
<li><p>关于夹逼定理的一般使用规律：</p>
<p>当变化部分的最大值与主体部分相比较是次量级就用夹逼原理，而当变化部分的最大值与其主体部分相比较是同量级就用定积分定义；</p>
<p>分子与分母同时变化时优先考虑分母变化。</p>
</li>
<li><p>对于n项连乘的数列极限，常用方法为夹逼原理或取对数化为n项和</p>
</li>
<li><p>对于递推关系定义的数列：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20231018094938103.png" alt="image-20231018094938103"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20231018095004948.png" alt="image-20231018095004948"></p>
</li>
</ol>
<h2 id="6-一元函数微分学"><a href="#6-一元函数微分学" class="headerlink" title="6.一元函数微分学"></a>6.一元函数微分学</h2><ol>
<li><p>连续、可导与可微的关系。反例：$f(x) &#x3D; \begin{cases}x^2sin\frac{1}{x},x\neq 0\0,x&#x3D;0 \end{cases}$处处可导，但x趋于0的导数不存在，从而f‘(x)再x &#x3D; 0处也不连续</p>
</li>
<li><p>关于高阶导数求导：</p>
<ol>
<li><p>使用定义</p>
</li>
<li><p>常用公式：<br>$$<br>(sinx)^{(n)} &#x3D; sin(x+\frac{n\pi}{2})\<br>(cosx)^{(n)} &#x3D; cos(x+\frac{n\pi}{2})\<br>(u\pm v)^{(n)} &#x3D; u^{(n)} + v^{(n)}\<br>(uv)^{(n)} &#x3D; \sum_{k&#x3D;0}^{n}C_n^ku^{(k)}v^{(n-k)}\<br>$$</p>
</li>
</ol>
</li>
<li><p>分段函数在分界点处的导数一般都要用定义求</p>
</li>
<li><p>f(x) &#x3D; g(x)|x - a|，其中g(x)在x &#x3D; a处连续，则f(x)在x &#x3D; a 处可导的充要条件是g(a) &#x3D; 0</p>
</li>
<li><p>f(x)可导$\nleftrightarrow$|f(x)|可导</p>
<p>$$<br>设f(x)连续：\<br>若f(x_0)\neq 0,则|f(x)|在x_0处可导\Leftrightarrow f(x)在x_0处可导\<br>若f(x_0)&#x3D; 0,则|f(x)|在x_0处可导\Leftrightarrow f(x_0) &#x3D; 0\<br>$$</p>
</li>
<li><p>$对于极坐标方程r &#x3D; f(\theta)，x &#x3D; f(\theta)cos\theta,y &#x3D; f(\theta)\sin\theta$</p>
</li>
<li><p>y &#x3D; f(g(x))，y’ &#x3D; f’(g(x))g’(x)，此时若g’(x) 不存在，并不能断定y’不存在，需用定义再次验证</p>
</li>
<li><p>f(x)的反函数是g(x),$g’’(x) &#x3D; -\frac{f’’(x)}{f’(x)^3}$</p>
</li>
<li><p>泰勒级数$f(x) &#x3D; \sum_{n&#x3D;0}^\infty \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n$</p>
</li>
<li><p>泰勒公式</p>
</li>
<li><p>曲率公式：$K &#x3D; \begin{cases}\frac{|y’’|}{(1+y’^2)^{3&#x2F;2}},y &#x3D; y(x)\\frac{|y’’x’-y’x’’|}{(x’^2+y’^2)^{3&#x2F;2}},参数方程\end{cases}$</p>
</li>
<li><p>曲率半径R &#x3D; 1&#x2F;K</p>
</li>
<li><p>证明根的存在性：零点定理、罗尔定理</p>
</li>
<li><p>求根的个数：单调性、罗尔定理推论</p>
</li>
<li><p>题目出现f(x) + f’(x) ,考虑构造$e^xf(x)$</p>
</li>
<li><p>与微分中值定理有关的证明题：</p>
<ol>
<li><p>$证明存在一个点\xi \in(a,b),使F(\xi,f(\xi),f’(\xi)) &#x3D; 0$</p>
<p>分析法，微分方程法 P81-86</p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20231018212401990.png"/>

<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20231018212855305.png" alt="image-20231018212855305"></p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20231018212418835.png"/>
</li>
<li><p>$证明存在两个中值点,\xi,\eta\in(a,b),使F[\xi,\eta,f(\xi),f(\eta),f’(\xi),f’(\eta)] &#x3D; 0$</p>
<ol>
<li><p>不要求两个点不相同</p>
<p>在同一区间上用两次中值定理（拉格朗日、柯西）</p>
</li>
<li><p>要求两个点不相同</p>
<p>将区间（a，b）分为两个子区间，在两个子区间上分别用拉格朗日中值定理</p>
</li>
</ol>
</li>
<li><p>$证明存在一个中值点\xi\in(a,b),使F[\xi,f^{(n)}(\xi)]\geq0(n&gt;&#x3D;2)$</p>
<p>用拉格朗日余项的泰勒公式，其中x<del>0</del>点选题目中提供函数值和导数值信息多的点。</p>
</li>
</ol>
</li>
</ol>
<h2 id="7-一元函数积分学"><a href="#7-一元函数积分学" class="headerlink" title="7. 一元函数积分学"></a>7. 一元函数积分学</h2><ol>
<li><p>原函数存在性定理：</p>
<ol>
<li>若f（x）在区间I上连续，则f（x）在区间I上必有原函数</li>
<li>若f（x）在区间I上有第一类间断点，则f（x）在区间I上没有原函数</li>
</ol>
</li>
<li><p>三种主要积分法：</p>
<ol>
<li>第一类换元法（凑微分法）</li>
<li>第二类换元法</li>
<li>分部积分法</li>
</ol>
</li>
<li><p>常见的不可积的积分：<br>$$<br>\int e^{x^2}dx\<br>\int \frac{sinx}{x}dx\<br>\int \frac{cosx}{x}dx\<br>$$</p>
</li>
<li><p>有理函数积分：</p>
<ol>
<li>一般方法（部分分式法）</li>
<li>特殊方法（加项减项拆项或凑微分降幂）</li>
</ol>
</li>
<li><p>三角有理式积分</p>
<ol>
<li>万能代换令 tan(x&#x2F;2) &#x3D; t</li>
<li>关于sinx的奇函数，凑dcosx</li>
<li>关于cosx的奇函数，凑dsinx</li>
<li>关于两者的奇函数，凑dtanx</li>
</ol>
</li>
<li><p>简单无理函数积分<br>$$<br>\int R(x,\sqrt[n]{\frac{ax+b}{cx+d}})dx<br>$$<br>令根式为t，将其化为有理函数积分进行运算</p>
</li>
<li><p>分母为二次式，考虑配方构成a^2 +&#x2F;- x^2的形式</p>
</li>
<li><p>出现根号内1+x^2 ，考虑令x &#x3D; tan（t）</p>
</li>
<li><p>出现1+cosx，考虑将其转化为cos（x&#x2F;2）</p>
</li>
<li><p>积分函数为分段函数时，考虑分界点连续</p>
</li>
<li><p>定积分的可积性：</p>
<ol>
<li><p>必要性：</p>
<p>积分存在，则积分函数的导数必有界</p>
</li>
<li><p>充分性：</p>
<ol>
<li>若积分函数在[a,b]连续，则积分必定存在</li>
<li>若积分函数在[a,b]有界，且只有有限个间断点，则积分必定存在</li>
<li>若积分函数在[a,b]只有有限个第一类间断点，则积分必定存在，</li>
</ol>
</li>
</ol>
</li>
<li><p>使用牛顿-莱布尼兹公式的前提是f(x)在闭区间上连续</p>
</li>
<li><p>$$<br>\int _0 ^{\frac{\pi}{2}} sin^nxdx &#x3D; \int _0 ^{\frac{\pi}{2}} cos^nxdx &#x3D; \begin{cases}<br>\frac{n-1}{n} *\frac{n-3}{n-2}…… * \frac{2}{3},n为大于1的奇数\<br>\frac{n-1}{n} *\frac{n-3}{n-2}…… * \frac{1}{2} * \frac{\pi}{2},n为偶数\end{cases}\<br>\int _0 ^\pi xf(sinx)dx &#x3D; \frac{\pi}{2}\int _0 ^\pi f(sinx)dx，其中f(x)连续<br>$$</p>
</li>
<li><p>积分中值定理<br>$$<br>\int _a^bf(x)dx &#x3D; f(\xi)(b-a)，其中f(x)在[a,b]上连续，a&lt;\xi&lt;b<br>$$</p>
</li>
<li><p>广义积分中值定理<br>$$<br>\int_a^bf(x)g(x)dx &#x3D; f(\xi)\int_a^bg(x)dx,a\leq \xi \leq b<br>其中f(x),g(x)在[a,b]上连续，且g(x)不变号<br>$$</p>
</li>
<li><p>求解有关定积分的极限：</p>
<ol>
<li>使用中值定理</li>
<li>夹逼</li>
<li>广义积分中值定理</li>
<li>洛必达法则</li>
<li>等价无穷小代换</li>
</ol>
</li>
<li><p>关注区间对称，考虑奇偶性</p>
</li>
<li><p>当被积函数的原函数不易求出的定积分计算时，可令x &#x3D; 上限 + 下限 - t，此类代换区间不变</p>
</li>
<li><p>柯西积分不等式<br>$$<br>(\int_a^bf(x)g(x)dx)^2 \leq \int_a^bf^2(x)dx \int_a^bg^2(x)dx<br>$$</p>
</li>
<li></li>
</ol>
<h1 id="高数题型"><a href="#高数题型" class="headerlink" title="高数题型"></a>高数题型</h1><ol>
<li>递推关系定义的数列求数列极限存在并求极限（P34-P37）</li>
<li>微分中值定理三类题型</li>
<li>求解有关定积分的极限：<ol>
<li>使用中值定理</li>
<li>夹逼</li>
<li>广义积分中值定理</li>
<li>洛必达法则</li>
<li>等价无穷小代换</li>
</ol>
</li>
</ol>
<h1 id="线代笔记"><a href="#线代笔记" class="headerlink" title="线代笔记"></a>线代笔记</h1><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h3 id="存在与唯一性问题："><a href="#存在与唯一性问题：" class="headerlink" title="存在与唯一性问题："></a>存在与唯一性问题：</h3><ol>
<li>方程组是否相容，即它是否至少有一个解？</li>
<li>若它有解，它是否只有一个解，即解是否唯一？</li>
</ol>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>每个矩阵行等价于唯一的简化阶梯形矩阵</p>
<h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>线性方程组相容的充要条件是增广矩阵的最右列不是主元列</p>
<h3 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h3><p>若A是m<em>n矩阵，它的各列为*<em>a</em></em><del>1</del>，<strong>a</strong><del>2</del>，…，<strong>a</strong><del>n</del>，而<strong>b</strong>属于R^m^，则矩阵方程 A<strong>x</strong> &#x3D; <strong>b</strong>  与向量方程 x<del>1</del> <strong>a</strong><del>1</del> + x<del>2</del> <strong>a</strong><del>2</del> + … + x<del>n</del> <strong>a</strong><del>n</del>&#x3D;<strong>b</strong></p>
<p>有相同的解集，它又与增广矩阵为[<strong>a</strong><del>1</del>	<strong>a</strong><del>2</del>	…	<strong>a</strong><del>n</del>	<strong>b</strong>]的线性方程组有相同的解集。</p>
<h3 id="定理4"><a href="#定理4" class="headerlink" title="定理4"></a>定理4</h3><p>设A是m*n矩阵，则下列命题是逻辑上等价的，也就是说，对某个A，它们都成立或者都不成立</p>
<ol>
<li>对R^m^中每个<strong>b</strong>，方程A<strong>x</strong> &#x3D; <strong>b</strong>有解</li>
<li>对R^m^中每个<strong>b</strong>都是A的列的一个线性组合</li>
<li>A的各列生成R^m^</li>
<li>A在每一行都有一个主元位置</li>
</ol>
<h3 id="定理5"><a href="#定理5" class="headerlink" title="定理5"></a>定理5</h3><p>若A是m*n矩阵，<strong>u</strong>和<strong>v</strong>是R^n^中向量，c是标量，则</p>
<ol>
<li>A( <strong>u</strong> + <strong>v</strong>) &#x3D; A<strong>u</strong>  +  A<strong>v</strong></li>
<li>A(c<strong>u</strong>) &#x3D; c(A<strong>u</strong>)</li>
</ol>
<h3 id="定理6"><a href="#定理6" class="headerlink" title="定理6"></a>定理6</h3><p>设方程A<strong>x</strong> &#x3D; <strong>b</strong> 对某个<strong>b</strong>是相容的，<strong>p</strong>为一个特解，则A<strong>x</strong> &#x3D; <strong>b</strong>的解集是所有形如 <strong>w</strong> &#x3D; <strong>p</strong> + <strong>v</strong><del>h</del>的向量的集，其中<strong>v</strong><del>h</del></p>
<p>是齐次方程A<strong>x</strong> &#x3D; 0的任意一个解</p>
<h3 id="定理7（线性相关集的特征）"><a href="#定理7（线性相关集的特征）" class="headerlink" title="定理7（线性相关集的特征）"></a>定理7（线性相关集的特征）</h3><p>两个或更多个向量的集合S &#x3D; {<strong>v</strong><del>1</del>，<strong>v</strong><del>2</del>，…，<strong>v</strong><del>p</del>}线性相关，当前仅当S中至少有一个向量是其它向量的线性组合。事实上，若S线性相关，且<strong>v</strong><del>1</del> !&#x3D; 0 ，则某个<strong>v</strong><del>j</del>（j&gt;1）是它前面向量的线性组合。</p>
<h3 id="定理8"><a href="#定理8" class="headerlink" title="定理8"></a>定理8</h3><p>若一个向量组的向量个数超过每个向量的元素个数，那么这个向量组线性相关，就是说，R^n^中任意向量组[<strong>v</strong><del>1</del>，<strong>v</strong><del>2</del>，…，<strong>v</strong><del>p</del>]当p&gt;n时线性相关</p>
<h3 id="定理9"><a href="#定理9" class="headerlink" title="定理9"></a>定理9</h3><p>若R^n^中向量组{<strong>v</strong><del>1</del>，<strong>v</strong><del>2</del>，…，<strong>v</strong><del>p</del>}包含零向量，则它线性相关。</p>
<h3 id="定理10"><a href="#定理10" class="headerlink" title="定理10"></a>定理10</h3><p>设T:R^n^ -&gt; R^m^为线性变换，则存在唯一的矩阵A，使得对R^n^中一切<strong>x</strong>，有 T(<strong>x</strong>) &#x3D; A <strong>x</strong></p>
<p>事实上，A是m<em>n矩阵，它的第j列是向量T(<strong>e</strong><del>j</del>)，其中*<em>e</em></em><del>j</del>是R^n^中单位矩阵<strong>I</strong><del>n</del>的第j列： A &#x3D; [T(<strong>e</strong><del>1</del>)，T(<strong>e</strong><del>2</del>)，…，T(<strong>e</strong><del>n</del>)]</p>
<h3 id="定理11"><a href="#定理11" class="headerlink" title="定理11"></a>定理11</h3><p>设T:R^n^ -&gt; R^m^为线性变换，则T是一对一的当且仅当方程A <strong>x</strong> &#x3D; 0仅有平凡解</p>
<h3 id="定理12"><a href="#定理12" class="headerlink" title="定理12"></a>定理12</h3><p>设T:R^n^ -&gt; R^m^为线性变换，设A为T的标准矩阵，则</p>
<ol>
<li>T把R^n^映上到R^m^，当前仅当A的列生成R^m^。</li>
<li>T是一对一的，当且仅当A的列线性无关。</li>
</ol>
<h2 id="矩阵代数"><a href="#矩阵代数" class="headerlink" title="矩阵代数"></a>矩阵代数</h2><h3 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a>定理1：</h3><p>设A，B，C是相同维数的矩阵，r与s为数，则有</p>
<ol>
<li>A + B &#x3D; B + A</li>
<li>(A + B) + C &#x3D; A + (B + C)</li>
<li>A + 0 &#x3D; A</li>
<li>r(A + B)  &#x3D; rA + rB</li>
<li>(r + s)A &#x3D; rA + sA</li>
<li>r(sA) &#x3D; (rs)A</li>
</ol>
<h3 id="定理2："><a href="#定理2：" class="headerlink" title="定理2："></a>定理2：</h3><p>设A为m*n矩阵，B和C的维数使下列各式的乘积有定义：</p>
<ol>
<li><p>A(BC) &#x3D; (AB)C		(乘法结合律)</p>
</li>
<li><p>A(B+C) &#x3D; AB + AC		(乘法左分配律)</p>
</li>
<li><p>(B+C)A  &#x3D; BA + CA	(乘法右分配律)</p>
</li>
<li><p>r(AB) &#x3D; (rA)B &#x3D; A(rB)，r为任意数</p>
</li>
<li><p>I<del>m</del>A &#x3D; A &#x3D; AI<del>n</del>	(矩阵乘法的恒等式)</p>
</li>
</ol>
<h3 id="定理3："><a href="#定理3：" class="headerlink" title="定理3："></a>定理3：</h3><ol>
<li>(A^T^)^T^ &#x3D; A</li>
<li>(A + B)^T^ &#x3D; A^T^ + B^T^</li>
<li>对任意数r，(rA)^T^ &#x3D; rA^T^</li>
<li>(AB)^T^ &#x3D; B^T^A^T^</li>
</ol>
<h3 id="定理4："><a href="#定理4：" class="headerlink" title="定理4："></a>定理4：</h3><p>设A &#x3D; $$\begin{bmatrix} a &amp; b \ c &amp; d \end{bmatrix}$$,若 $$ ad - bc \neq 0$$，则A可逆且$$ A^{-1} &#x3D; \frac{1}{ad-bc} \begin{bmatrix} d&amp;b \ -c&amp;a \end{bmatrix}$$，若$$ ad -bc &#x3D; 0$$,则A不可逆</p>
<h3 id="定理5："><a href="#定理5：" class="headerlink" title="定理5："></a>定理5：</h3><p>若A是可逆$n\times n$矩阵，则对每一对$\mathbb{R^n}$中的<strong>b</strong>，方程A<strong>x</strong> &#x3D; <strong>b</strong>有唯一解<strong>x</strong> &#x3D; A^-1^ <strong>b</strong></p>
<h3 id="定理6："><a href="#定理6：" class="headerlink" title="定理6："></a>定理6：</h3><ol>
<li>若A是可逆矩阵，则A^-1^也可逆而且(A^-1^)^-1^ &#x3D; A</li>
<li>若A和B都是$ n\times n $可逆矩阵，则AB也可逆，且其逆是A和B的逆矩阵按相反顺序的乘积，即<br>(AB)^-1^ &#x3D; B^-1^A^-1^</li>
<li>若A可逆，则A^T^也可逆，且其逆是A^-1^的转置，即(A^T^)^-1^ &#x3D; (A^-1^)^T^</li>
</ol>
<h3 id="定理7："><a href="#定理7：" class="headerlink" title="定理7："></a>定理7：</h3><p>$n \times n$矩阵A是可逆的，当且仅当A行等价与I<del>n</del>，这时，把A化简为I<del>n</del>的一系列初等行变换同时把I<del>n</del>变成A^-1^</p>
<h3 id="定理8：（可逆矩阵定理）"><a href="#定理8：（可逆矩阵定理）" class="headerlink" title="定理8：（可逆矩阵定理）"></a>定理8：（可逆矩阵定理）</h3><p>设A为$n \times n$矩阵，则下列命题是等价的，即对某一特定的A，它们同时为真或同时为假。</p>
<ol>
<li>A是可逆矩阵</li>
<li>A行等价于$n \times n$单位矩阵</li>
<li>A有n个主元位置</li>
<li>方程A <strong>x</strong> &#x3D; <strong>0</strong> 仅有平凡解</li>
<li>A的各列线性无关</li>
<li>线性变换$x \mapsto Ax$是一对一的</li>
<li>对$\mathbb{R^n}$中任意<strong>b</strong>，方程A <strong>x</strong> &#x3D; <strong>b</strong>至少有一个解</li>
<li>A的各列生成$\mathbb{R^n}$</li>
<li>线性变换$x \mapsto Ax$把$\mathbb{R^n}$映上到$\mathbb{R^n}$</li>
<li>存在$n \times n$矩阵C使CA &#x3D; I</li>
<li>存在$n \times n$矩阵D使AD &#x3D; I</li>
<li>A^T^是可逆矩阵</li>
</ol>
<h3 id="定理9："><a href="#定理9：" class="headerlink" title="定理9："></a>定理9：</h3><p>（1）对所有$\mathbb{R^n}$中的<strong>x</strong>，S(T(<strong>x</strong>)) &#x3D; <strong>x</strong></p>
<p>（2）对所有$\mathbb{R^n}$中的<strong>x</strong>，T(S(<strong>x</strong>)) &#x3D; <strong>x</strong></p>
<p> 设T：$\mathbb{R^n} \rightarrow \mathbb{R^n}$为线性变换，A为T的标准矩阵，则T可逆当且仅当A是可逆矩阵，这时由$S(x) &#x3D; A^{-1}x$定义的线性变换S是满足（1）和（2）的唯一函数。</p>
<h3 id="定理10：（AB的列行展开）"><a href="#定理10：（AB的列行展开）" class="headerlink" title="定理10：（AB的列行展开）"></a>定理10：（AB的列行展开）</h3><p>若A是$m\times n$矩阵，B是$n\times p$矩阵，则$AB &#x3D; [col_1(A) col_2(A) … col_n(A)]\begin{bmatrix}row_1(B)\row_2(B)\…\row_n(B)\end{bmatrix} &#x3D; col_1(A)row_1(B) +…+ col_n(A)row_n(B)$</p>
<h3 id="定理11："><a href="#定理11：" class="headerlink" title="定理11："></a>定理11：</h3><p>设C为某一经济体系的消耗矩阵，<strong>d</strong>为最终需求，若C和<strong>d</strong>的元素非负，C的每一列的和小于1，则(I - C)^-1^存在，产出向量 <strong>x</strong> &#x3D; (I - C)^-1^ <strong>d</strong>有非负元素，且是下列方程的唯一解：<strong>x</strong> &#x3D; C<strong>x</strong> + <strong>d</strong></p>
<h3 id="定理12："><a href="#定理12：" class="headerlink" title="定理12："></a>定理12：</h3><p>$m\times n$矩阵A的零空间是$\mathbb{R^n}$的子空间，等价地，n个未知数的m个齐次线性方程的方程组A <strong>x</strong> &#x3D; <strong>0</strong>的所有解的集合是$\mathbb{R^n}$的子空间</p>
<h3 id="定理13："><a href="#定理13：" class="headerlink" title="定理13："></a>定理13：</h3><p>矩阵A的主元列构成A的列空间的基</p>
<h3 id="定理14：（秩定理）"><a href="#定理14：（秩定理）" class="headerlink" title="定理14：	（秩定理）"></a>定理14：	（秩定理）</h3><p>如果一矩阵A有n列，则$rank A + dim Nul A &#x3D; n$</p>
<h3 id="定理15：-（基定理）"><a href="#定理15：-（基定理）" class="headerlink" title="定理15： 	（基定理）"></a>定理15： 	（基定理）</h3><p>设H是$\mathbb{R^n}$的p维子空间，H中的任何恰好由p个元素组成的线性无关集构成H的一个基，并且，H中任何生成的H的p个向量集也构成H的一个基。</p>
<h3 id="定理16：（可逆矩阵定理（续））"><a href="#定理16：（可逆矩阵定理（续））" class="headerlink" title="定理16：（可逆矩阵定理（续））"></a>定理16：（可逆矩阵定理（续））</h3><p>设A是一$n\times n$矩阵，则下面的每个命题与A是可逆矩阵的命题等价：</p>
<ol>
<li>A的列向量构成$\mathbb{R^n}$的一个基</li>
<li>$Col\ A &#x3D; \mathbb{R^n}$</li>
<li>$dim\ Col A &#x3D; n$</li>
<li>$rank\ A &#x3D; n$</li>
<li>$Nul\ A &#x3D; {0}$</li>
<li>$dim\ NulA &#x3D; 0$</li>
</ol>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h3 id="定理1：-1"><a href="#定理1：-1" class="headerlink" title="定理1："></a>定理1：</h3><p>$n\times$n矩阵A的行列式可按任意行或列的余因子展开式来计算，按第i行展开的余因子展开式为：<br>$$<br>det\ A &#x3D; a_{i1}C_{i1} + a_{i2}C_{i2} + … + a_{in}C_{in}<br>$$<br>按第j列的余因子展开式为：<br>$$<br>det\ A &#x3D; a_{1j}C_{1j} + a_{2j}C_{2j} + … + a_{nj}C_{nj}<br>$$</p>
<h3 id="定理2：-1"><a href="#定理2：-1" class="headerlink" title="定理2："></a>定理2：</h3><p>若A为三角阵，则det A等于A的主对角线上元素的乘积</p>
<h3 id="定理3：（行变换）"><a href="#定理3：（行变换）" class="headerlink" title="定理3：（行变换）"></a>定理3：（行变换）</h3><p>令A是一个方阵</p>
<ol>
<li>若A的某一行的倍数加到另一行得矩阵B，则$det B &#x3D; det A$</li>
<li>若A的两行互换得到矩阵B，则$det B &#x3D; - det A$</li>
<li>若A的某行乘以k倍得到矩阵B，则$det B &#x3D; k* det A$</li>
</ol>
<h3 id="定理4：-1"><a href="#定理4：-1" class="headerlink" title="定理4："></a>定理4：</h3><p>方阵A是可逆的当且仅当$det\ A \neq 0$</p>
<h3 id="定理5：-1"><a href="#定理5：-1" class="headerlink" title="定理5："></a>定理5：</h3><p>若A为一个$n\times n$矩阵，则$det\ A^T &#x3D; det\ A$</p>
<h3 id="定理6：（乘法的性质）"><a href="#定理6：（乘法的性质）" class="headerlink" title="定理6：（乘法的性质）"></a>定理6：（乘法的性质）</h3><p>若A和B均为$n\times n$矩阵，则$det\ AB &#x3D; (detA)(detB)$</p>
<h3 id="定理7：（克拉默法则）"><a href="#定理7：（克拉默法则）" class="headerlink" title="定理7：（克拉默法则）"></a>定理7：（克拉默法则）</h3><p>设A是一个可逆的$n\times n$矩阵，对$\mathbb{R^n}$中任意向量<strong>b</strong>，方程A<strong>x</strong> &#x3D; <strong>b</strong>的唯一解可由下式给出：<br>$$<br>x_i &#x3D; \frac{det\ A_i(b)}{det\ A},i &#x3D; 1,2,..,n<br>$$</p>
<h3 id="定理8：-（逆矩阵公式）"><a href="#定理8：-（逆矩阵公式）" class="headerlink" title="定理8： （逆矩阵公式）"></a>定理8： （逆矩阵公式）</h3><p>设A是一个可逆的$n\times n矩阵$，则$ A^{-1} &#x3D; \frac{1}{det\ A} adjA$,其中adj A称为伴随矩阵</p>
<h3 id="定理9：-1"><a href="#定理9：-1" class="headerlink" title="定理9："></a>定理9：</h3><p>若A是一个$2\times 2$矩阵，则由A的列确定的平行四边形的面积为$|det\ A|$</p>
<p>若A是一个$3\times 3$矩阵，则由A的列确定的平行六面体的体积为$|det\ A|$</p>
<h3 id="定理10："><a href="#定理10：" class="headerlink" title="定理10："></a>定理10：</h3><p>设T：$\mathbb{R^n}\rightarrow \mathbb{R^n}$是由一个$2\times 2$矩阵A确定的线性变换，若S是$\mathbb{R^n}$中一个平行四边形，则<br>$$<br>{T(S)的面积} &#x3D; |det\ A| * {S的面积}<br>$$<br>若T是由一个$3\times 3$矩阵A确定的线性变换，而S是R^3^中的一个平行六面体，则<br>$$<br>{T(S)的体积} &#x3D; |det\ A| * {S的体积}<br>$$</p>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><ol>
<li>关于副对角线的行列式</li>
</ol>
<h1 id="begin-bmatrix-a-11-a-12-…-a-1-n-1-a-1n-a-21-a-22-…-a-2-n-1-0-…-…-…-…-…-a-n1-0-…-0-0-end-bmatrix"><a href="#begin-bmatrix-a-11-a-12-…-a-1-n-1-a-1n-a-21-a-22-…-a-2-n-1-0-…-…-…-…-…-a-n1-0-…-0-0-end-bmatrix" class="headerlink" title="$$\begin{bmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1,n-1}&amp;a_{1n}\            a_{21}&amp;a_{22}&amp;…&amp;a_{2,n-1}&amp;0\            …&amp;…&amp;…&amp;…&amp;…\            a_{n1}&amp;0&amp;…&amp;0&amp;0            \end{bmatrix}"></a>$$<br>\begin{bmatrix}a_{11}&amp;a_{12}&amp;…&amp;a_{1,n-1}&amp;a_{1n}\<br>            a_{21}&amp;a_{22}&amp;…&amp;a_{2,n-1}&amp;0\<br>            …&amp;…&amp;…&amp;…&amp;…\<br>            a_{n1}&amp;0&amp;…&amp;0&amp;0<br>            \end{bmatrix}</h1><h1 id="begin-bmatrix-0-…-0-a-1n-0-…-a-2-n-1-a-2n-…-…-…-…-a-n1-…-a-n-n-1-a-nn-end-bmatrix"><a href="#begin-bmatrix-0-…-0-a-1n-0-…-a-2-n-1-a-2n-…-…-…-…-a-n1-…-a-n-n-1-a-nn-end-bmatrix" class="headerlink" title="\begin{bmatrix}0&amp;…&amp;0&amp;a_{1n}\0&amp;…&amp;a_{2,n-1}&amp;a_{2n}\…&amp;…&amp;…&amp;…\a_{n1}&amp;…&amp;a_{n,n-1}&amp;a_{nn}\end{bmatrix}"></a>\begin{bmatrix}0&amp;…&amp;0&amp;a_{1n}\<br>0&amp;…&amp;a_{2,n-1}&amp;a_{2n}\<br>…&amp;…&amp;…&amp;…\<br>a_{n1}&amp;…&amp;a_{n,n-1}&amp;a_{nn}\end{bmatrix}</h1><p>(-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2,n-1}…a_{n1}<br>$$</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230603101112099.png" alt="image-20230603101112099"></p>
<h2 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h2><h3 id="定理1：-2"><a href="#定理1：-2" class="headerlink" title="定理1："></a>定理1：</h3><p>若<strong>v<del>1</del></strong>,<strong>v<del>2</del></strong>, … **v<del>p</del>**在向量空间V中，则Span{<strong>v<del>1</del></strong>, … <strong>v<del>p</del></strong>}是V的一个子空间</p>
<h3 id="定理2：-2"><a href="#定理2：-2" class="headerlink" title="定理2："></a>定理2：</h3><p>$m\times n$矩阵A的零空间是$\mathbb{R^n}$的一个子空间。等价地，m个方程，n个未知数的齐次线性方程组A<strong>x</strong> &#x3D; <strong>0</strong>的全体解的集合是$\mathbb{R^n}$的一个子空间</p>
<h3 id="定理3：-1"><a href="#定理3：-1" class="headerlink" title="定理3："></a>定理3：</h3><p>$m\times n$矩阵A的列空间是$\mathbb{R^m}$的一个子空间</p>
<h3 id="定理4：-2"><a href="#定理4：-2" class="headerlink" title="定理4："></a>定理4：</h3><p>两个或多个向量组成的有编号的向量集合{<strong>v<del>1</del></strong>, … ,<strong>v<del>p</del></strong>}（如果$v_1 \neq 0,$）是线性相关的，当且仅当某<strong>v<del>j</del><strong>（j&gt;1）是其前面向量</strong>v<del>1</del></strong>, …, **v<del>j-1</del>**的线性组合。</p>
<h3 id="定理5：（生成集定理）"><a href="#定理5：（生成集定理）" class="headerlink" title="定理5：（生成集定理）"></a>定理5：（生成集定理）</h3><p>令S &#x3D; {<strong>v<del>1</del></strong>, … ,<strong>v<del>p</del></strong>}是V中的向量集，H &#x3D; Span{<strong>v<del>1</del></strong>, … ,<strong>v<del>p</del></strong>}</p>
<ol>
<li>若S中某一个向量（比如说是<strong>v</strong><del>k</del>）是S中其余向量的线性组合，则S中去掉<strong>v</strong><del>k</del>后形成的集合仍然可以生成H。</li>
<li>若$H\neq {0}$，则S的某一子集是H的一个基。</li>
</ol>
<h3 id="定理6：-1"><a href="#定理6：-1" class="headerlink" title="定理6："></a>定理6：</h3><p>矩阵A的主元列构成Col A的一个基</p>
<h3 id="定理7：（唯一表示定理）"><a href="#定理7：（唯一表示定理）" class="headerlink" title="定理7：（唯一表示定理）"></a>定理7：（唯一表示定理）</h3><p>令$\mathcal{B} &#x3D; $ {<strong>b<del>1</del></strong>, … ,<strong>b<del>n</del></strong>}是向量空间V的一个基，则对V中的每个向量<strong>x</strong>，存在唯一的一组数c<del>1</del>, …, c<del>n</del>使得 $x &#x3D; c_1\mathbf{b_1} +\ …\ +c_n\mathbf{b_n}$</p>
<h3 id="定理8："><a href="#定理8：" class="headerlink" title="定理8："></a>定理8：</h3><p>令$\mathcal{B} &#x3D; $ {<strong>b<del>1</del></strong>, … ,<strong>b<del>n</del></strong>}是向量空间V的一个基，则坐标映射$\mathbf{x}\mapsto[\mathbf{x}]_{\mathcal{B}}$是一个由V映上到$\mathbb{R^n}$的一对一的线性变换</p>
<h3 id="定理9：-2"><a href="#定理9：-2" class="headerlink" title="定理9："></a>定理9：</h3><p>若向量空间V具有一组基$\mathcal{B} &#x3D; $ {<strong>b<del>1</del></strong>, … ,<strong>b<del>n</del></strong>}，则V中任意包含多于n个向量的集合一定线性相关。</p>
<h3 id="定理10：-1"><a href="#定理10：-1" class="headerlink" title="定理10："></a>定理10：</h3><p>若向量空间V有一组基含有n个向量，则V的另一组基一定恰好含有n个向量 </p>
<h3 id="定理11：-1"><a href="#定理11：-1" class="headerlink" title="定理11："></a>定理11：</h3><p>令H是有限维向量空间V的子空间，若有必要的话，H中任一个线性无关集均可以扩充为H的一个基，H也是有限维的并且<br>$$<br>dim H \leq dimV<br>$$</p>
<h3 id="定理12：（基定理）"><a href="#定理12：（基定理）" class="headerlink" title="定理12：（基定理）"></a>定理12：（基定理）</h3><p>令V是一个p维向量空间，$p\geq1$，V中任意含有p个元素的线性无关集必然是V的一个基。任意含有p个元素且生成V的集合自然是V的一个基。 </p>
<h3 id="定理13：-1"><a href="#定理13：-1" class="headerlink" title="定理13："></a>定理13：</h3><p>若两个矩阵A和B行等价，则他们的行空间相同。若B是阶梯形矩阵，则B的非零行构成A的行空间的一个基同时也是B的行空间的一个基。</p>
<h3 id="定理14：（秩定理）-1"><a href="#定理14：（秩定理）-1" class="headerlink" title="定理14：（秩定理）"></a>定理14：（秩定理）</h3><p>$m\times n$矩阵A的列空间和行空间的维数相等，这个公共的维数（即A的秩）还等于A的主元位置的个数且满足方程<br>$$<br>rank\ A + dim\ Nul\ A &#x3D; n<br>$$</p>
<h3 id="定理15："><a href="#定理15：" class="headerlink" title="定理15："></a>定理15：</h3><p>设$\mathcal{B} &#x3D; $ {<strong>b<del>1</del></strong>, … ,<strong>b<del>n</del></strong>}和$\mathcal{C} &#x3D; $ {<strong>c<del>1</del></strong>, … ,<strong>c<del>n</del></strong>}是向量空间V的基，则存在一个$n\times n$矩阵$\mathop{P}\limits_{\mathcal{C}\leftarrow\mathcal{B}}$使得<br>$$<br>[\mathbf x]<em>{\mathcal{C}} &#x3D; \mathop{P}\limits</em>{\mathcal{C}\leftarrow\mathcal{B}}[\mathbf x]<em>{\mathcal{B}}<br>$$<br>$\mathop{P}\limits</em>{\mathcal{C}\leftarrow\mathcal{B}}$的列是基B中向量的C-坐标向量，即$\mathop{P}\limits_{\mathcal{C}\leftarrow\mathcal{B}} &#x3D; \begin{pmatrix}[\mathbf{b_1}<em>{\mathcal{C}}]&amp;[\mathbf{b_2}</em>{\mathcal{C}}]&amp;…&amp;[\mathbf{b_n}_{\mathcal{C}}]\end{pmatrix}$</p>
<h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><h3 id="定理1：-3"><a href="#定理1：-3" class="headerlink" title="定理1："></a>定理1：</h3><p>三角矩阵的主对角线的元素是其特征值</p>
<h3 id="定理2：-3"><a href="#定理2：-3" class="headerlink" title="定理2："></a>定理2：</h3><p>$\lambda_1,…,\lambda_r是n\times n$矩阵A相异的特征值，$\mathbf{v}_1,…,\mathbf{v}_r$对应的特征向量，那么向量集合{<strong>v<del>1</del></strong>, … ,<strong>v<del>r</del></strong>}线性无关</p>
<h3 id="可逆矩阵定理（续）："><a href="#可逆矩阵定理（续）：" class="headerlink" title="可逆矩阵定理（续）："></a>可逆矩阵定理（续）：</h3><p>设A是$n\times n$矩阵，则A是可逆的当且仅当</p>
<ol>
<li><p>0不是A的特征值</p>
</li>
<li><p>A的行列式不等于0</p>
</li>
</ol>
<h3 id="定理3：（行列式的性质）"><a href="#定理3：（行列式的性质）" class="headerlink" title="定理3：（行列式的性质）"></a>定理3：（行列式的性质）</h3><p>设A和B是$n\times n$矩阵</p>
<ol>
<li><p>A可逆的充要条件是$det\ A \neq 0$</p>
</li>
<li><p>$det\ AB &#x3D; (det\ A)(det\ B)$</p>
</li>
<li><p>$det\ A^T &#x3D; det\ A$</p>
</li>
<li><p>若a是三角形矩阵，那么det A是A主对角线元素的乘积</p>
</li>
<li><p>对A作行替换不改变其行列式值。作一次行交换，行列式值符号改变一次。数乘一行后，行列式值等于用此数乘原来的行列式值。</p>
</li>
</ol>
<h3 id="定理4：-3"><a href="#定理4：-3" class="headerlink" title="定理4："></a>定理4：</h3><p>若$n\times n$矩阵A和B是相似的，那么它们有相同的特征多项式，从而有相同的特征值（和相同的重数）</p>
<h3 id="定理5：（对角化定理）"><a href="#定理5：（对角化定理）" class="headerlink" title="定理5：（对角化定理）"></a>定理5：（对角化定理）</h3><p>$n\times n$矩阵A可对角化的充分必要条件是A有n个线性无关的特征向量</p>
<h3 id="定理6：-2"><a href="#定理6：-2" class="headerlink" title="定理6："></a>定理6：</h3><p>有n个相异特征值的$n\times n$矩阵可对角化</p>
<h3 id="定理7：-1"><a href="#定理7：-1" class="headerlink" title="定理7："></a>定理7：</h3><p>设A是$n\times n$矩阵，其相异的特征值是$\lambda_1,…,\lambda_p$</p>
<ol>
<li><p>对于$ 1\leq k\leq p,\lambda_k$的特征空间的维数小于或等于$\lambda_k$的代数重数</p>
</li>
<li><p>矩阵A可对角化的充分必要条件是所有不同特征空间的维数之和为n。即（i）特征对象式可完全分解为线性因子，（ii）每个$\lambda_k$的特征空间的维数等于$\lambda_k$的代数重数。</p>
</li>
<li><p>若A可对角化，$\mathcal{B}_k$是对应于$\lambda_k$的特征空间的基，则集合$\mathcal{B}_1,…,\mathcal{B}_p$中所有向量的集合是$\mathbb{R^n}$的特征向量基。</p>
</li>
</ol>
<h1 id="线代上课笔记"><a href="#线代上课笔记" class="headerlink" title="线代上课笔记"></a>线代上课笔记</h1><h2 id="行列式-1"><a href="#行列式-1" class="headerlink" title="行列式"></a>行列式</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>不同行不同列元素乘积的代数和。</p>
<h4 id="关于正负号（二三阶行列式）："><a href="#关于正负号（二三阶行列式）：" class="headerlink" title="关于正负号（二三阶行列式）："></a>关于正负号（二三阶行列式）：</h4><p>正对角线：+</p>
<p>副对角线：-</p>
<h4 id="排列、逆序、逆序数："><a href="#排列、逆序、逆序数：" class="headerlink" title="排列、逆序、逆序数："></a>排列、逆序、逆序数：</h4><p>1，2，。。。，n组成的有序数组称为n阶排列</p>
<p>大的数排在小的数前面叫逆序，这两个数构成逆序</p>
<p>一个排列的逆序的总数称为排列的逆序数，逆序数为偶数，偶排列，奇数，奇排列</p>
<h4 id="关于正负号（n阶）："><a href="#关于正负号（n阶）：" class="headerlink" title="关于正负号（n阶）："></a>关于正负号（n阶）：</h4><p>逆序数为奇数，负号，偶数，正号</p>
<h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><p>经过转置行列式值不变</p>
<p>某行有公因数可提出 ，特别地，若某行元素全为0，则行列式值为0</p>
<p>两行互换，行列式值变号，特别地，两行相同或两行成比例，行列式值为0</p>
<p>如果行列式每一项都是两个数的和，则可以把行列式拆成两个行列式之和</p>
<p>把某行的k倍加到另一行，行列式值不变  </p>
<h3 id="行列式按行（列）展开公式"><a href="#行列式按行（列）展开公式" class="headerlink" title="行列式按行（列）展开公式"></a>行列式按行（列）展开公式</h3><h4 id="余子式："><a href="#余子式：" class="headerlink" title="余子式："></a>余子式：</h4><p>去掉某一行某一列元素后剩余的行列式，$M_{ij}$</p>
<h4 id="代数余子式："><a href="#代数余子式：" class="headerlink" title="代数余子式："></a>代数余子式：</h4><p>与余子式相比，多了正负号，$A_{ij} &#x3D; (-1)^{i+j}M_{ij}$</p>
<p> 特别地：  某一行的所有元素与另一行相应元素的代数余子式乘积之和等于0</p>
<h4 id="重要公式："><a href="#重要公式：" class="headerlink" title="重要公式："></a>重要公式：</h4><p>对于三角矩阵，</p>
<ol>
<li><p>正对角线：行列式值为对角线元素的积，</p>
</li>
<li><p>副对角线：行列式值为$(-1)^{\frac{1}{2}n(n-1)}$乘以对角线元素的积</p>
</li>
</ol>
<p>拉普拉斯行列式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604190443180.png" alt="image-20230604190443180"></p>
<p> 范德蒙行列式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604190457241.png" alt="image-20230604190457241"></p>
<h3 id="克拉默法则："><a href="#克拉默法则：" class="headerlink" title="克拉默法则："></a>克拉默法则：</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604210400911.png" alt="image-20230604210400911"></h4><p> <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604210431206.png" alt="image-20230604210431206"></p>
<h4 id="推论："><a href="#推论：" class="headerlink" title="推论："></a>推论：</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604210749601.png" alt="image-20230604210749601"></p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="概念、运算"><a href="#概念、运算" class="headerlink" title="概念、运算"></a>概念、运算</h3><p> 运算：矩阵加法、常数数乘、矩阵乘法</p>
<p>矩阵乘法：结合律、分配律</p>
<p>对角矩阵：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604213337804.png" alt="image-20230604213337804"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604213353624.png" alt="image-20230604213353624"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604213248337.png" alt="image-20230604213248337"></p>
<p>矩阵的转置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604213456460.png" alt="image-20230604213456460"></p>
<h3 id="伴随矩阵、可逆矩阵"><a href="#伴随矩阵、可逆矩阵" class="headerlink" title="伴随矩阵、可逆矩阵"></a>伴随矩阵、可逆矩阵</h3><h4 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604220139503.png" alt="image-20230604220139503"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604220204593.png" alt="image-20230604220204593"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604220906444.png" alt="image-20230604220906444"></p>
<p><img src="C:\Users\zhenghaosheng\AppData\Roaming\Typora\typora-user-images\image-20230604221131320.png" alt="image-20230604221131320"></p>
<h4 id="性质推导："><a href="#性质推导：" class="headerlink" title="性质推导："></a>性质推导：</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rgbhi/article/details/123286265">(109条消息) 伴随矩阵的性质-CSDN博客</a></p>
<h4 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h4><p>AB &#x3D; BA &#x3D; E<br>B为A的逆矩阵，表示为A^-1^</p>
<p>一个矩阵可逆，其逆矩阵唯一</p>
<p>矩阵可逆，行列式不等于0  </p>
<p><strong>推论：A，B是n阶矩阵，且AB &#x3D; E，则A^-1^ &#x3D; B</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604222356492.png" alt="image-20230604222356492"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604222422051.png" alt="image-20230604222422051"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604222624243.png" alt="image-20230604222624243"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230604222746926.png" alt="image-20230604222746926"></p>
<h3 id="初等变换、初等矩阵"><a href="#初等变换、初等矩阵" class="headerlink" title="初等变换、初等矩阵"></a>初等变换、初等矩阵</h3><h4 id="初等变换："><a href="#初等变换：" class="headerlink" title="初等变换："></a>初等变换：</h4><p>行变换：倍乘、互换、倍加</p>
<p>列变换：</p>
<h4 id="初等矩阵："><a href="#初等矩阵：" class="headerlink" title="初等矩阵："></a>初等矩阵：</h4><p>单位矩阵经过<strong>一次</strong>初等变换所得到的矩阵称为<strong>初等矩阵</strong></p>
<p>初等矩阵P<strong>左乘矩阵A</strong>，其乘积PA就是矩阵A作一次与P同样的<strong>行变换</strong></p>
<p>相应地，初等矩阵<strong>右乘矩阵A</strong>，其乘积AP就是矩阵A作一次与同样的<strong>列变换</strong></p>
<p>初等矩阵均可逆，且其逆是<strong>同一类型</strong>的初等矩阵    </p>
<h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><h4 id="分块矩阵的运算"><a href="#分块矩阵的运算" class="headerlink" title="分块矩阵的运算"></a>分块矩阵的运算</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605092453791.png" alt="image-20230605092453791"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605092638801.png" alt="image-20230605092638801"></p>
<p>特别地：</p>
<p><strong>遇到求方程组解，考虑按列分块；</strong><br><strong>遇到求向量、秩，考虑按行分块或按列分块</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605094948338.png" alt="image-20230605094948338"></p>
<p><strong>C &#x3D; AB的列向量可由A的列向量线性表出</strong></p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605095048845.png"/>

<p><strong>C &#x3D; AB的行向量可由B的行向量线性表出</strong></p>
<p><strong>特别地：若A可逆，则B &#x3D; A^-1^C，B的行向量可由C的行向量线性表出</strong></p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605095357224.png"/>

<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605095549797.png" alt="image-20230605095549797"></p>
<h4 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605102003492.png" alt="image-20230605102003492"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605102040672.png" alt="image-20230605102040672"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605102103375.png" alt="image-20230605102103375"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605102146679.png" alt="image-20230605102146679"></p>
<h3 id="向量："><a href="#向量：" class="headerlink" title="向量："></a>向量：</h3><h4 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h4><p>n个数构成的有序数组称为n维向量  </p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605103306098.png" alt="image-20230605103306098"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605103328522.png" alt="image-20230605103328522"></p>
<h4 id="Schmidt正交化"><a href="#Schmidt正交化" class="headerlink" title="Schmidt正交化"></a>Schmidt正交化</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605103732143.png" alt="image-20230605103732143"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605103814915.png" alt="image-20230605103814915"></p>
<h4 id="线性表出："><a href="#线性表出：" class="headerlink" title="线性表出："></a>线性表出：</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605104224619.png" alt="image-20230605104224619"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605104307242.png" alt="image-20230605104307242"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605105124198.png" alt="image-20230605105124198"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605105300240.png" alt="image-20230605105300240"></p>
<h4 id="线性相关"><a href="#线性相关" class="headerlink" title="线性相关"></a>线性相关</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605110453629.png" alt="image-20230605110453629"></p>
<p><strong>线性相关 &lt;&#x3D;&gt; 齐次方程组有非0解 &lt;&#x3D;&gt; 秩小于未知数的个数 &lt;&#x3D;&gt; 行列式 &#x3D;0</strong> </p>
<h4 id="线性无关"><a href="#线性无关" class="headerlink" title="线性无关"></a>线性无关</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605212404003.png" alt="image-20230605212404003"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605212617223.png" alt="image-20230605212617223"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605212851055.png" alt="image-20230605212851055"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605213559080.png" alt="image-20230605213559080"></p>
<h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605215240293.png" alt="image-20230605215240293"></p>
<p> <strong>定理：经初等变换矩阵的秩不变</strong> </p>
<p><strong>秩的性质</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605220235069.png" alt="image-20230605220235069"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605220837882.png" alt="image-20230605220837882"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605221013377.png" alt="image-20230605221013377"></p>
<p><strong>r（A） &#x3D; A的列秩 &#x3D; A的行秩</strong></p>
<h4 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605222619411.png" alt="image-20230605222619411"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605223203290.png" alt="image-20230605223203290"></p>
<p>   <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605225048434.png" alt="image-20230605225048434"></p>
<p>矩阵等价：A经初等变换可变成B</p>
<p>向量组等价：可互相线性表示</p>
<p><strong>矩阵等价，向量组不一定等价</strong></p>
<p><strong>若向量组1可由向量组2线性表示，则向量组1的秩$\leq$向量组2的秩</strong></p>
<h4 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230605225833038.png" alt="image-20230605225833038"></p>
<h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><h4 id="Ax-0"><a href="#Ax-0" class="headerlink" title="Ax &#x3D; 0"></a>Ax &#x3D; 0</h4><p>$A_{m\times n}x &#x3D; 0$必有零解，若有非零解,则</p>
<p>r(A) &lt; n</p>
<p>A的列向量组线性相关</p>
<p>推论：</p>
<p><strong>当m&lt;n时，Ax &#x3D; 0必有非0解</strong></p>
<p><strong>当m&#x3D;n时，Ax &#x3D; 0有非0解&lt;&#x3D;&gt;|A| &#x3D; 0</strong></p>
<p><strong>齐次方程组若有非0解，则有无数个解，其中线性相关的解（自由变量）  的个数为 n - r(A)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606092140264.png" alt="image-20230606092140264"></p>
<h4 id="Ax-b"><a href="#Ax-b" class="headerlink" title="Ax &#x3D; b"></a>Ax &#x3D; b</h4><p>可能无解、可能唯一解、可能多解</p>
<p>注：$\overline{A}$为增广矩阵</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606094051373.png" alt="image-20230606094051373"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606094330635.png" alt="image-20230606094330635"></p>
<h4 id="方程组应用"><a href="#方程组应用" class="headerlink" title="方程组应用"></a>方程组应用</h4><h4 id="公共解、同解"><a href="#公共解、同解" class="headerlink" title="公共解、同解"></a>公共解、同解</h4><h2 id="特征值、特征向量"><a href="#特征值、特征向量" class="headerlink" title="特征值、特征向量"></a>特征值、特征向量</h2><h3 id="特征值、特征向量-1"><a href="#特征值、特征向量-1" class="headerlink" title="特征值、特征向量"></a>特征值、特征向量</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606143416585.png" alt="image-20230606143416585"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606144346037.png" alt="image-20230606144346037"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606144403762.png" alt="image-20230606144403762"></p>
<p>特征值有重根，特征向量不一定有多个<br>$$<br>Aa &#x3D; \lambda a\<br>A^2 a  &#x3D; \lambda^2 a\<br>(A+kE)a &#x3D; (\lambda + k)a<br>$$<br>A和A^T^的特征值相同，但特征向量不一定相同</p>
<h3 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606152216691.png" alt="image-20230606152216691"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606152535723.png" alt="image-20230606152535723"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606153009484.png" alt="image-20230606153009484"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606153119720.png" alt="image-20230606153119720"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606153146531.png" alt="image-20230606153146531"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606153558745.png" alt="image-20230606153558745"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606153721782.png" alt="image-20230606153721782"></p>
<h4 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h4><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606155326546.png" alt="image-20230606155326546"></p>
<h3 id="实对称矩阵"><a href="#实对称矩阵" class="headerlink" title="实对称矩阵"></a>实对称矩阵</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606170824189.png" alt="image-20230606170824189"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606171413050.png" alt="image-20230606171413050"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230606171205932.png" alt="image-20230606171205932"></p>
<h2 id="二次型–与特征值、特征向量的关系"><a href="#二次型–与特征值、特征向量的关系" class="headerlink" title="二次型–与特征值、特征向量的关系"></a>二次型–与特征值、特征向量的关系</h2><h3 id="二次型概念"><a href="#二次型概念" class="headerlink" title="二次型概念"></a>二次型概念</h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607170852094.png" alt="image-20230607170852094"></p>
<p><strong>其中A为对称矩阵，A^T^ &#x3D; A，称为二次型的矩阵</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607184358657.png" alt="image-20230607184358657"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607185442867.png" alt="image-20230607185442867"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607185704541.png" alt="image-20230607185704541"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607185741720.png" alt="image-20230607185741720"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607185848786.png" alt="image-20230607185848786"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607185938516.png" alt="image-20230607185938516"></p>
<p>  <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607190712873.png" alt="image-20230607190712873"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607190906476.png" alt="image-20230607190906476"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607191010922.png" alt="image-20230607191010922"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607191607137.png" alt="image-20230607191607137"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607191620856.png" alt="image-20230607191620856"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607191900717.png" alt="image-20230607191900717"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607192221262.png" alt="image-20230607192221262"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607192855606.png" alt="image-20230607192855606"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607193052481.png" alt="image-20230607193052481"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230607193155730.png" alt="image-20230607193155730"></p>
<p><strong>使用配方法化二次型时，若原式不存在平方，可考虑进行平方差代换凑出平方</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610144200902.png" alt="image-20230610144200902"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610144226334.png" alt="image-20230610144226334"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610144239348.png" alt="image-20230610144239348"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610144359474.png" alt="image-20230610144359474"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610145353644.png" alt="image-20230610145353644"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610145543812.png" alt="image-20230610145543812"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610145625014.png" alt="image-20230610145625014"></p>
<h3 id="正定二次型"><a href="#正定二次型" class="headerlink" title="正定二次型"></a>正定二次型<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610150518689.png" alt="image-20230610150518689"></h3><p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610150607602.png" alt="image-20230610150607602"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610150919677.png" alt="image-20230610150919677"></p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610150954909.png" alt="image-20230610150954909"></p>
<p> <img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230610151152063.png" alt="image-20230610151152063"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/math/" data-id="clqwhy486000hikvf359i48o3" data-title="Math" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Math/" rel="tag">Math</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Latex语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/Latex%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:49.400Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://img-blog.csdn.net/2018041621294865?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lFTl9DU0RO/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180416213036844?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lFTl9DU0RO/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180416213119987?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lFTl9DU0RO/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180416213126857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lFTl9DU0RO/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/Latex%E8%AF%AD%E6%B3%95/" data-id="clqwhy47p0007ikvfa70t42qh" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-dataStructure" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/dataStructure/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:49.382Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/02/dataStructure/">data Structure</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h1><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><h2 id="2-栈、队列和数组"><a href="#2-栈、队列和数组" class="headerlink" title="2.栈、队列和数组"></a>2.栈、队列和数组</h2><ol>
<li><p>n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C_{2n}^{n}$</p>
</li>
<li><p>采用共享栈的好处是节省存储空间，降低发生上溢的可能。</p>
</li>
<li><p>将递归算法转换为非递归算法，通常需要借助栈来实现这种转换。但不是必定的，比如斐波那契数列。</p>
</li>
<li><p>前序遍历需要借助栈来实现。</p>
</li>
<li><p>特殊矩阵压缩元素下标之间的对应关系：<br>$$<br>对称矩阵：<br>k &#x3D;<br>\begin{cases}<br>\frac{i*(i-1)}{2}+j-1，i\geq j(下三角区和主对角线元素）\<br>\frac{j*(j-1)}{2}+i-1, i &lt; j（上三角区元素）\<br>\end{cases}<br>\<br>下三角矩阵：<br>k &#x3D;<br>\begin{cases}<br>\frac{i*(i-1)}{2}+j-1, i\geq j(下三角区和主对角线元素）\<br>\frac{n*(n+1)}{2}, i&lt;j（上三角区元素）\<br>\end{cases}<br>\<br>上三角矩阵：<br>k &#x3D;<br>\begin{cases}<br>\frac{(i-1)*（2n-i+2)}{2}+j-i, i\leq j(上三角区和主对角线元素）\<br>\frac{n*(n+1)}{2}, i&gt;j（下三角区元素）\<br>\end{cases}<br>\<br>三对角矩阵：<br>下标为k &#x3D; 2i+j-3,且i&#x3D; \lfloor \frac{k+1}{3}+1 \rfloor<br>\<br>稀疏矩阵：<br>使用三元组（行标，列标，值）存储，但会失去随机存取的特性。<br>$$</p>
</li>
</ol>
<h2 id="3-串"><a href="#3-串" class="headerlink" title="3.串"></a>3.串</h2><h2 id="4-树与二叉树"><a href="#4-树与二叉树" class="headerlink" title="4. 树与二叉树"></a>4. 树与二叉树</h2><h3 id="1-树"><a href="#1-树" class="headerlink" title="1.树"></a>1.树</h3><h4 id="1-定义（部分）"><a href="#1-定义（部分）" class="headerlink" title="1.定义（部分）"></a>1.定义（部分）</h4><ol>
<li>树中一个结点的孩子个数称为该结点的度，树的所有结点中度最大的结点的度称为树的度。</li>
<li>度为0的结点称为叶子结点，度大于0的结点称为分支结点。</li>
<li>结点的深度是从根节点开始自顶向下逐层累加的，结点的高度是从叶节点开始自底向上逐层累加的。</li>
<li>树的高度、深度是树中结点的最大层数。</li>
<li>有序树和无序树是不同的。</li>
<li>路径是由两个结点之间所经过的结点序列构成的，路径长度是路径上所经过的边的个数。</li>
<li>树的路径长度是从树根到每个结点的路径长度的总和。</li>
<li>由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的孩子之间不存在路径。</li>
<li>森林是多棵互不相交的树的集合。</li>
</ol>
<h4 id="2-树的性质"><a href="#2-树的性质" class="headerlink" title="2. 树的性质"></a>2. 树的性质</h4><ol>
<li><p>树中的结点数等于所有结点的度数之和加1.</p>
</li>
<li><p>度为m的树第i层上至多有m^(i-1)个结点(i&gt;&#x3D;1)。<br>$$<br>m^(i-1) (i&gt;&#x3D;1)<br>$$</p>
</li>
<li><p>高度为h的m叉树至多有(m^h-1)&#x2F;(m-1)个结点。<br>$$<br>(m^h-1)&#x2F;(m-1)<br>$$</p>
</li>
<li><p>具有n个结点的m叉树的最小高度为<br>$$<br>\lceil \log_{m}(n(m-1)+1)\rceil<br>$$</p>
</li>
</ol>
<h3 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h3><h4 id="1-定义（部分）-1"><a href="#1-定义（部分）-1" class="headerlink" title="1.定义（部分）"></a>1.定义（部分）</h4><ol>
<li><p>二叉树为有序树，若将其左右子树颠倒，则成为另一棵不同的二叉树，即使树中结点只有一棵子树，也要区分它是左子树还是右子树。</p>
</li>
<li><p>二叉树的物种基本形态：空二叉树、只有根节点、只有左子树、只有右子树、左右子树都有。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230414175822589.png" alt="image-20230414175822589"></p>
<ol start="3">
<li>二叉树和度为2的有序树的区别：<ol>
<li>度为2的树至少有3个结点，而二叉树可以为空。</li>
<li>度为2的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无需区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序，而二叉树的结点次序不是相对与另一结点而言的，而是确定的。</li>
</ol>
</li>
</ol>
<h4 id="2-特殊二叉树"><a href="#2-特殊二叉树" class="headerlink" title="2.特殊二叉树"></a>2.特殊二叉树</h4><h5 id="1-满二叉树"><a href="#1-满二叉树" class="headerlink" title="1. 满二叉树"></a>1. 满二叉树</h5><ul>
<li><p>除叶节点外的每个结点度数均为2</p>
</li>
<li><p>对于编号为i的结点，若有双亲，则其双亲为$\lfloor i&#x2F;2 \rfloor$</p>
<p>若有左孩子，则左孩子为2i，若有右孩子，则右孩子为2i+1</p>
</li>
</ul>
<h5 id="2-完全二叉树"><a href="#2-完全二叉树" class="headerlink" title="2. 完全二叉树"></a>2. 完全二叉树</h5><ul>
<li><p>若$i&lt;\lfloor i&#x2F;2 \rfloor$则结点i为分支结点，否则为叶结点</p>
</li>
<li><p>叶结点只可能在最大层次的两层上出现，对于最大层次上的叶结点，都依次排列在该层最左边的位置上</p>
</li>
<li><p>若存在度为1的结点，则只可能有1个，且该结点只有左孩子而无右孩子（重要特征）</p>
</li>
<li><p>按层序编号后，一旦出现某节点（编号为i）为叶结点或只有左孩子，则编号大于i的结点均为叶结点</p>
</li>
<li><p>若n为奇数，则每个分支结点都有左右孩子，若n为偶数，则编号最大的分支结点（编号为n&#x2F;2）只有左孩子而无右孩子，其余分支结点左右孩子都有</p>
</li>
</ul>
<h5 id="3-二叉排序树"><a href="#3-二叉排序树" class="headerlink" title="3. 二叉排序树"></a>3. 二叉排序树</h5><ul>
<li>左子树上的所有结点的关键字均小于根节点的关键字</li>
<li>右子树上的所有结点的关键字均大于根节点的关键字</li>
<li>左子树和右子树又各为一棵二叉排序树</li>
</ul>
<h5 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4. 平衡二叉树"></a>4. 平衡二叉树</h5><ul>
<li>树上任意一个结点的左子树和右子树的深度之差不超过1</li>
</ul>
<h4 id="3-二叉树的性质"><a href="#3-二叉树的性质" class="headerlink" title="3. 二叉树的性质"></a>3. 二叉树的性质</h4><ol>
<li><p>非空二叉树上的叶结点数等于度为2的结点数+1，即$n_0 &#x3D; n_2 + 1$</p>
<p>拓展到任意一棵树，结点数量为n，则边的数量为 n - 1</p>
</li>
<li><p>非空二叉树上第k层至多有2^(k-1)^个结点（k&gt;&#x3D;1)</p>
</li>
<li><p>高度为h的二叉树至多有2^h^-1个结点（h&gt;&#x3D;1）</p>
</li>
<li><p>对完全二叉树（从上到下，从左到右依次编号1，2…)</p>
<ul>
<li><p>当i &gt; 1，结点i的双亲的编号为 $\lfloor i&#x2F;2 \rfloor$</p>
</li>
<li><p>当2i &lt;&#x3D; n ,结点i的左孩子编号为2i，否则无左孩子</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>当2i + 1 &lt;&#x3D; n, 结点i的右孩子编号为2i + 1，否则无右孩子</p>
</li>
<li><p>结点i所在层次（深度）为$\lfloor log_2i \rfloor + 1$</p>
</li>
</ul>
<ol start="5">
<li><p>具有n个结点的完全二叉树的高度为$\lfloor log_2n \rfloor + 1 或 \lceil log_2(n+1) \rceil$</p>
</li>
<li><p>补充</p>
<ul>
<li><p>对于一棵二叉树，其度数为1的结点若存在，则其数量必为奇数</p>
</li>
<li><p>对于一棵高度为h的满k叉树，其编号为i的第一个孩子结点(若存在)的编号为j, j满足$j &#x3D; (i-1)*k +2$</p>
<p>依此可推导出其第m个子女的编号为$(i-1)*k +m + 1 (1&lt;&#x3D;m&lt;&#x3D;k)$</p>
<p>相应的，编号为i的结点的双亲结点（若存在）的编号为$\lfloor (i-2)&#x2F;m \rfloor + 1$</p>
<p>推导过程如图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230414234826493.png" alt="image-20230414234826493"></p>
</li>
</ul>
</li>
</ol>
<h3 id="3-二叉树的遍历和线索二叉树"><a href="#3-二叉树的遍历和线索二叉树" class="headerlink" title="3. 二叉树的遍历和线索二叉树"></a>3. 二叉树的遍历和线索二叉树</h3><h4 id="1-二叉树的遍历"><a href="#1-二叉树的遍历" class="headerlink" title="1.二叉树的遍历"></a>1.二叉树的遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">binaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    binaryTreeNode *lchild, *rchild;</span><br><span class="line">&#125;binaryTreeNode,*binaryTree;</span><br></pre></td></tr></table></figure>



<ol>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>递归算法和非递归算法的转换</li>
<li>层次遍历</li>
<li>由遍历序列构造二叉树</li>
</ol>
<h4 id="2-线索二叉树"><a href="#2-线索二叉树" class="headerlink" title="2.线索二叉树"></a>2.线索二叉树</h4><h5 id="1-线索二叉树的基本概念"><a href="#1-线索二叉树的基本概念" class="headerlink" title="1. 线索二叉树的基本概念"></a>1. 线索二叉树的基本概念</h5><ol>
<li><p>规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230415150457665.png" alt="image-20230415150457665"></p>
<p>其中标志域的含义：</p>
<blockquote>
<p><code>ltag</code> &#x3D; 0, <code>lchild</code>域指示结点的左孩子<br><code>ltag</code> &#x3D; 1，<code>lchild</code>指示结点的前驱</p>
<p><code>rtag</code> &#x3D; 0, <code>rchild</code>域指示结点的右孩子<br><code>rtag</code> &#x3D; 1，<code>rchild</code>指示结点的后继</p>
</blockquote>
<p>线索二叉树的存储结构描述如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    ThreadNode *lchild,*rchild;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*Threadtree;</span><br></pre></td></tr></table></figure>

<p>此种结构又被称为线索链表，加上线索的二叉树称为线索二叉树</p>
</li>
</ol>
<h5 id="2-中序线索二叉树的构造"><a href="#2-中序线索二叉树的构造" class="headerlink" title="2. 中序线索二叉树的构造"></a>2. 中序线索二叉树的构造</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ThreadNode *lchild,*rchild;</span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*Threadtree;</span><br><span class="line"><span class="comment">//通过中序遍历对二叉树线索化的递归算法如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(Threadtree &amp;p,Threadtree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;lchild,pre);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        <span class="built_in">InThread</span>(p-&gt;rchild,pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过中序遍历建立线索二叉树的主过程算法如下：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(Threadtree T)</span></span>&#123;</span><br><span class="line">    Threadtree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T,pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求中序线索二叉树中中序序列下的第一个结点：</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求中序线索二叉树中结点p在中序序列下的后继：</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Firstnode</span>(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-中序线索二叉树的遍历"><a href="#3-中序线索二叉树的遍历" class="headerlink" title="3. 中序线索二叉树的遍历"></a>3. 中序线索二叉树的遍历</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用上面两个算法，可以写出不含头节点的中序线索二叉树的中序遍历的算法：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">Firstnode</span>(T);p!=<span class="literal">nullptr</span>;p=<span class="built_in">Nextnode</span>(p))&#123;</span><br><span class="line">        <span class="comment">//visit(p);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-先序线索二叉树和后序线索二叉树"><a href="#4-先序线索二叉树和后序线索二叉树" class="headerlink" title="4. 先序线索二叉树和后序线索二叉树"></a>4. 先序线索二叉树和后序线索二叉树</h5><h3 id="4-树、森林"><a href="#4-树、森林" class="headerlink" title="4. 树、森林"></a>4. 树、森林</h3><h4 id="1-树的存储结构"><a href="#1-树的存储结构" class="headerlink" title="1. 树的存储结构"></a>1. 树的存储结构</h4><ol>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法</li>
</ol>
<h4 id="2-树、森林与二叉树的转换"><a href="#2-树、森林与二叉树的转换" class="headerlink" title="2. 树、森林与二叉树的转换"></a>2. 树、森林与二叉树的转换</h4><ol>
<li><p>树与二叉树的对应关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230425161230886.png" alt="image-20230425161230886"></p>
</li>
<li><p>森林与二叉树的对应关系：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230425161250033.png" alt="image-20230425161250033"></p>
</li>
</ol>
<h4 id="3-树和森林的遍历"><a href="#3-树和森林的遍历" class="headerlink" title="3. 树和森林的遍历"></a>3. 树和森林的遍历</h4><ol>
<li><p>树的遍历：</p>
<ul>
<li>先根遍历</li>
<li>后根遍历</li>
</ul>
</li>
<li><p>森林的遍历</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
</ul>
</li>
<li><p>树和森林的遍历与二叉树的遍历的对应关系：</p>
<table>
<thead>
<tr>
<th align="left">树</th>
<th>森林</th>
<th>二叉树</th>
</tr>
</thead>
<tbody><tr>
<td align="left">先根遍历</td>
<td>先序遍历</td>
<td>先序遍历</td>
</tr>
<tr>
<td align="left">后根遍历</td>
<td>中序遍历</td>
<td>中序遍历</td>
</tr>
</tbody></table>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230425161314257.png" alt="image-20230425161314257"></p>
<h3 id="5-树与二叉树的应用"><a href="#5-树与二叉树的应用" class="headerlink" title="5. 树与二叉树的应用"></a>5. 树与二叉树的应用</h3><h5 id="1-哈夫曼树和哈夫曼编码"><a href="#1-哈夫曼树和哈夫曼编码" class="headerlink" title="1. 哈夫曼树和哈夫曼编码"></a>1. 哈夫曼树和哈夫曼编码</h5><ol>
<li><p>哈夫曼树定义<br>$$<br>WPL &#x3D; \sum_{i&#x3D;1}^{n}w_{i}l_{i}<br>$$</p>
</li>
<li><p>哈夫曼树构造</p>
<p><strong>注意权值排列要有一定规律，从左到右或从右到左</strong></p>
</li>
<li><p>哈夫曼编码</p>
<p>哈夫曼编码相对于等长编码具有压缩数据的效果，利用哈夫曼树可以设计出总长度最短的二进制前缀编码。</p>
</li>
</ol>
<h5 id="2-并查集"><a href="#2-并查集" class="headerlink" title="2. 并查集"></a>2. 并查集</h5><h5 id="3-哈夫曼树应用"><a href="#3-哈夫曼树应用" class="headerlink" title="3. 哈夫曼树应用"></a>3. 哈夫曼树应用</h5><ol>
<li><p>两个不等长有序表的合并最坏情况下的比较次数：m+n-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">分析过程：</span><br><span class="line">设置两个指针分别指向两个表（A,B）当前要比较的结点；</span><br><span class="line">不妨设：p为A的工作指针，q为B的工作指针</span><br><span class="line"></span><br><span class="line">初始时，两个指针都指向各自的首结点。</span><br><span class="line">开始比较：</span><br><span class="line">p和q比（A_1和B_1比）,假设A_1小，则p后移一位指向A_2;</span><br><span class="line">再让A_2和B_1比，此时B_1小，q后移指向B_2；</span><br><span class="line">此时A_2和B_2比，此时A_2小，p后移指向A_3；</span><br><span class="line">此时A_3和B_2比，此时B_2小，q后移指向B_3;…</span><br><span class="line">…</span><br><span class="line">发现，q和p两个工作指针，依次后移，你走一个，我走一个，两个表全部都走一遍是最坏的情况！</span><br><span class="line">都走一遍那不是 m+n次？？？</span><br><span class="line"></span><br><span class="line">减一是因为：</span><br><span class="line">p和q是依次后移的，肯定会有一个指针先走完整个表，不可能出现两个表同时到达终点吧！依次后移啊喂！</span><br><span class="line">最坏的情况就是，p走完了，q还差一个，不用比了啊，没有对手！ -1！</span><br><span class="line"></span><br><span class="line">这就是为什么是 m+n-1!</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-二叉树相关性质补充"><a href="#6-二叉树相关性质补充" class="headerlink" title="6.二叉树相关性质补充"></a>6.二叉树相关性质补充</h3><ul>
<li>二叉树中序遍历的最后一个结点一定是从根开始沿右子女指针链走到底的结点（参考书P140 第一题）</li>
<li>设m, n 为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是：n在m左方</li>
<li>设m, n 为一棵二叉树上的两个结点，在后序遍历时，n在m前的条件是：n是m子孙</li>
<li>在二叉树中有两个结点m和n，若m是n的祖先，则使用后序遍历可以找到从m到n的路径（参考书p141 第五题）</li>
<li>前序遍历需要借助栈。二叉树的前序序列和中序序列的关系相当于以前序序列作为入栈次序，以中序序列作为出栈次序。（参考书P141 第十二题）</li>
<li>先序序列和后序序列只可唯一确定树的根结点，但无法划分左右子树。</li>
<li>二叉树是一种逻辑结构，但线索二叉树是加上线索后的链表结构，即他是二叉树在计算机内部的一种存储结构，所以是一种物理结构。</li>
<li>后序二叉树的遍历仍需要栈的支持（参考书P142 第二十五题）</li>
<li>二叉树的前序序列和后序序列正好相反，说明该二叉树高度等于结点数，不存在兄弟结点。</li>
</ul>
<h2 id="5-图"><a href="#5-图" class="headerlink" title="5.图"></a>5.图</h2><h3 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1. 图的基本概念"></a>1. 图的基本概念</h3><h4 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1. 图的定义"></a>1. 图的定义</h4><ol>
<li>线性表可以为空表，树可以为空树，但图不可以是空图。图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点没有边。</li>
<li>有向图</li>
<li>无向图</li>
<li>简单图、多重图<ul>
<li>简单图： 不存在重复边，不存在顶点到自身的边</li>
<li>多重图： 图中某两个顶点之间的边数大于1条，有允许顶点通过1条边和自身关联</li>
</ul>
</li>
<li>完全图（也称简单完全图）</li>
<li>子图</li>
<li>连通、连通图和连通分量</li>
<li>强连通图、强连通分量</li>
<li>生成树、生成森林</li>
<li>顶点的度、入度和出度</li>
<li>边的权和网</li>
<li>稠密图、稀疏图</li>
<li>路径、路径长度和回路</li>
<li>简单路径、简单回路</li>
<li>距离</li>
<li>有向树</li>
</ol>
<h3 id="2-图的存储及基本操作"><a href="#2-图的存储及基本操作" class="headerlink" title="2. 图的存储及基本操作"></a>2. 图的存储及基本操作</h3><h4 id="1-邻接矩阵法"><a href="#1-邻接矩阵法" class="headerlink" title="1. 邻接矩阵法"></a>1. 邻接矩阵法</h4><ul>
<li><p>用一个一维数组存储图中顶点的信息</p>
</li>
<li><p>用一个二维数组存储图中边的信息</p>
<blockquote>
<p>注意：</p>
<p>无向图的邻接矩阵的对称矩阵，对规模特大的邻接矩阵可采用压缩存储</p>
<p>邻接矩阵表示法的空间复杂度为O(n^2)，其中n为图的顶点数|V|</p>
<p>稠密图适合使用邻接矩阵的存储表示</p>
</blockquote>
</li>
</ul>
<h4 id="2-邻接表法"><a href="#2-邻接表法" class="headerlink" title="2. 邻接表法"></a>2. 邻接表法</h4><p>图的邻接表存储结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;<span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex;</span><br><span class="line">   	ArcNode *next;</span><br><span class="line">    <span class="comment">//Infotype info;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123;<span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *first;</span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;<span class="comment">//邻接表</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;</span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure>

<p>图的邻接表存储方法具有以下特点：</p>
<ol>
<li><p>若G为无向图，则所需的存储空间为<br>$$<br>O(|V| + 2*|E|)<br>$$<br>若G为有向图，则所需的存储空间为：<br>$$<br>O(|V| + |E|)<br>$$</p>
</li>
<li><p>对于稀疏图，使用邻接表表示将极大地节省存储空间</p>
</li>
<li><p>若要查询给定一节点的所有邻边，使用邻接表较快；<br>若要查询两个节点间是否存在边，则使用邻接矩阵可以马上查到</p>
</li>
<li><p>对于邻接表而言，求给定一个顶点的出度只需计算其邻接表中的结点个数，但求其顶点的入度则需要遍历全部的邻接表。因此，可以采取逆邻接表的存储方式加速求解给定顶点的入度。</p>
</li>
<li><p>图的邻接表表示并不唯一，因为各边结点的链接次序是随意的。</p>
</li>
</ol>
<h4 id="3-十字链表（有向图）"><a href="#3-十字链表（有向图）" class="headerlink" title="3. 十字链表（有向图）"></a>3. 十字链表（有向图）</h4><h4 id="4-邻接多重表（无向图）"><a href="#4-邻接多重表（无向图）" class="headerlink" title="4. 邻接多重表（无向图）"></a>4. 邻接多重表（无向图）</h4><h4 id="5-图的基本操作"><a href="#5-图的基本操作" class="headerlink" title="5. 图的基本操作"></a>5. 图的基本操作</h4><h3 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3. 图的遍历"></a>3. 图的遍历</h3><h4 id="1-广度优先搜索"><a href="#1-广度优先搜索" class="headerlink" title="1. 广度优先搜索"></a>1. 广度优先搜索</h4><h5 id="1-BFS算法的性能分析"><a href="#1-BFS算法的性能分析" class="headerlink" title="1. BFS算法的性能分析"></a>1. BFS算法的性能分析</h5><ol>
<li>无论是邻接表还是邻接矩阵的存储方式，BFS算法都需要借助一个辅助队列Q，n个顶点均需入队一次，在最坏的情况下，空间复杂度为$$ O(|v|) $$</li>
<li>采用邻接表存储方式时，时间复杂度为$$ O(|V| +|E|) $$</li>
<li>采用邻接矩阵存储方式时，时间复杂度为$$ O(|V|^2 ) $$</li>
</ol>
<h5 id="2-BFS算法求解单源最短路径问题"><a href="#2-BFS算法求解单源最短路径问题" class="headerlink" title="2. BFS算法求解单源最短路径问题"></a>2. BFS算法求解单源最短路径问题</h5><h5 id="3-广度优先生成树"><a href="#3-广度优先生成树" class="headerlink" title="3. 广度优先生成树"></a>3. 广度优先生成树</h5><h4 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2. 深度优先搜索"></a>2. 深度优先搜索</h4><h5 id="1-DFS算法的性能分析"><a href="#1-DFS算法的性能分析" class="headerlink" title="1. DFS算法的性能分析"></a>1. DFS算法的性能分析</h5><ol>
<li>DFS算法是一个递归算法，需要借助一个递归工作栈，其空间复杂度为$$ O(|V|) $$</li>
<li>采用邻接表存储方式时，时间复杂度为$$ O(|V| +|E|) $$</li>
<li>采用邻接矩阵存储方式时，时间复杂度为$$ O(|V|^2 ) $$</li>
</ol>
<h5 id="2-深度优先的生成树和生成森林"><a href="#2-深度优先的生成树和生成森林" class="headerlink" title="2. 深度优先的生成树和生成森林"></a>2. 深度优先的生成树和生成森林</h5><h4 id="3-图的遍历和图的连通性"><a href="#3-图的遍历和图的连通性" class="headerlink" title="3. 图的遍历和图的连通性"></a>3. 图的遍历和图的连通性</h4><h3 id="4-图的应用"><a href="#4-图的应用" class="headerlink" title="4. 图的应用"></a>4. 图的应用</h3><h4 id="1-最小生成树"><a href="#1-最小生成树" class="headerlink" title="1. 最小生成树"></a>1. 最小生成树</h4><blockquote>
<p>最小生成树性质：</p>
<ol>
<li>最小生成树并不唯一，即树形不唯一；当图G中的各边权值互不相等时，G的最小生成树是唯一的；若无向连通图G的边数比顶点数少1，即G本身为一棵树时候，G的最小生成树就是它本身。</li>
<li>最小生成树的权值之和总是唯一的。</li>
<li>最小生成树的边数为顶点数减1。</li>
</ol>
</blockquote>
<ol>
<li><p>prim算法</p>
<p>时间复杂度为$$ O(|V|^2)$$，不依赖于边的数量，适用于求解边稠密图的最小生成树</p>
</li>
<li><p>Kruskal算法</p>
<p>采用堆来存放边的集合，每次选择最小权值的边只需$$ O(log_2{|E|})$$的时间，此外，由于生成树T中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，因此可以采用并查集的数据结构来描述T，从而构造T的时间复杂度为$$O(|E|log_2|E|) $$。因此Kruskal算法适合于边稀疏而顶点较多的图。</p>
</li>
</ol>
<h4 id="2-最短路径"><a href="#2-最短路径" class="headerlink" title="2. 最短路径"></a>2. 最短路径</h4><ol>
<li><p>Dijkstra算法（单源最短路径，即某一顶点到其他各顶点的最短路径）</p>
<p>Dijkstra算法是基于贪心策略的，使用邻接矩阵时，时间复杂度为 $$O(|V|^2)$$  , 使用带权的邻接表时，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，时间复杂度仍为 $O(|V|^2)$ ,另外，求解源点到某个特定顶点的最短路径和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度也为 $$O(|V|^2)$$</p>
<blockquote>
<p>值得注意的是，边上带有负权值时，Dijkstra算法并不适用。</p>
</blockquote>
</li>
<li><p>FLoyd算法（每队顶点间的最短路径）</p>
<p>Floyd算法的时间复杂度是$O(|V|)$,不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是非常小的，即使对于中等规模的输入来说，它仍然是相当有效的。</p>
<blockquote>
<p>Floyd算法允许图中带有负权值的边，但不允许有包含带负权值的边组成的回路。</p>
<p>Floyd算法同样适用于带权无向图，因为带权无向图可视为权din值相同往返二重边的有向图。</p>
<p>也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点最为源点，并且在所有边权值均非负时，运行一次Dijkstra算法，其时间复杂度为$O(|V|^2) * |V| &#x3D; O(|V|^3)$</p>
</blockquote>
</li>
</ol>
<h4 id="3-有向无环图描述表达式"><a href="#3-有向无环图描述表达式" class="headerlink" title="3. 有向无环图描述表达式"></a>3. 有向无环图描述表达式</h4><ol>
<li><p>定义</p>
<p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。</p>
<p>有向无环图是描述含有公共子式的的表达式的有效工具。例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/image-20230510160255610.png"></p>
</li>
</ol>
<h4 id="4-拓扑排序"><a href="#4-拓扑排序" class="headerlink" title="4.拓扑排序"></a>4.拓扑排序</h4><p>​	1. AOV 网：若用DAG图表示一个工程，其顶点表示活动，用有向边&lt; V<del>i</del> ,  V<del>j</del>&gt;表示活动V<del>i</del> 必须先于活动V<del>j</del> 进行的这样一种关系，，则将这种有向图称为<strong>顶点表示活动的网络</strong>, 记为AOV网。	在AOV网中，活动V<del>i</del>是活动V<del>j</del>的直接前驱，活动V<del>j</del>是活动V<del>i</del>的直接后继，这种前驱和后继关系具有传递性，且任何活动V<del>i</del>不能以它自己作为自己的前驱或后继。</p>
<p>​	2. 拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p>
<ul>
<li><p>每个顶点出现且只出现一次</p>
</li>
<li><p>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B在顶点A的路径</p>
<blockquote>
<p>拓扑排序实现： 从AOV网中选择一个没有前驱的顶点并输出，从网中删除该顶点和所有以它为起点的有向边。重复以上步骤知道当前AOV网为空或当前网中不存在无前驱的结点为止，后一种情况说明有向图中必然有环。</p>
<p>逆拓扑排序：选择没有后继的结点</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>由于输出每个顶点的同时还要删除以它为起点的边，故采用<strong>邻接表</strong>存储时拓扑排序的时间复杂度为<strong>O(|V| + |E|)</strong>, 采用<strong>邻接矩阵</strong>存储时拓扑排序的时间复杂度为**O(|V|^2^)**，此外，利用上一节的深度优先遍历也可实现拓扑排序。</li>
<li>对于一般的图来说，若其邻接矩阵为三角矩阵，则存在拓扑序列，反之不一定成立。</li>
</ol>
<h4 id="5-关键路径"><a href="#5-关键路径" class="headerlink" title="5. 关键路径"></a>5. 关键路径</h4><ol>
<li>AOE网： 在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为<strong>用边表示的网络</strong>，简称<strong>AOE网</strong>。AOE网和AOV网都是有向无环图，不同在于它们的边和顶点代表的含义是不同的，AOE网中的边有权值，而AOV网中的边无权值，仅表示顶点之间的前后关系。</li>
<li>AOE网具有一下两个性质：<ul>
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。</li>
<li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。</li>
</ul>
</li>
<li>在AOE网中，从源点到汇点的所有路径中，具有最大路径长度路径称为关键路径，而把关键路径上的活动称为关键活动。</li>
</ol>
<h3 id="5-图相关性质补充"><a href="#5-图相关性质补充" class="headerlink" title="5. 图相关性质补充"></a>5. 图相关性质补充</h3><ol>
<li><p>有向图的拓扑有序序列唯一，图中每个顶点的入度和出度不一定最多为1.参考P227T08</p>
</li>
<li><p>在拓扑排序算法中为暂存入度为0的节点，可以使用栈，也可以使用队列。参考同上。</p>
</li>
<li><p>若一个有向图的邻接矩阵为三角矩阵（对角线以下的元素为0），则图中必不存在环，因此其拓扑序列必然存在。参考P227T11</p>
</li>
<li><p>有向无环图的拓扑序列唯一并不能确定该图。参考P227T12</p>
</li>
<li><p>使用Prim算法从不同顶点开始得到的最小生成树不一定相同。参考P228T18</p>
</li>
<li><p>某个活动的时间余量 &#x3D; Ve - Vl。</p>
</li>
</ol>
<h2 id="6-查找"><a href="#6-查找" class="headerlink" title="6.查找"></a>6.查找</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>在数据集合中寻找满足某种条件的数据元素的过程称为查找。</p>
</li>
<li><p>查找表（查找结构）</p>
<p>用于查找的数据集合称为查找表。对查找表进行的操作一般有4种：</p>
<ul>
<li>查询某个特定的数据元素是否在查找表中</li>
<li>检索满足条件的某个特定数据元素的各种属性</li>
<li>在查找表种插入一个数据元素</li>
<li>在查找表中删除某个数据元素</li>
</ul>
</li>
<li><p>静态查找表</p>
<p>无需动态地插入或删除的查找表称为静态查找表。</p>
<p>适合静态查找表的方法有：顺序查找，折半查找。散列查找等；</p>
<p>适合动态查找表的查找方法有：二叉排序树的查找，散列查找等。</p>
</li>
<li><p>关键字</p>
<p>数据元素中唯一表示该元素中的某个数据项的值。</p>
</li>
<li><p>平均查找长度</p>
<p>在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为</p>
<p>$$<br>ASL &#x3D; \sum_{i&#x3D;1}^nP_iC_i<br>$$</p>
<p>式中，n是查找表的长度，P<del>i</del>是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即P<del>i</del> &#x3D; 1&#x2F;n；C<del>i</del>是找到第i个数据元素所需进行的比较次数，平均查找长度是衡量算法效率的最主要的指标。</p>
</li>
</ol>
<h3 id="顺序查找与折半查找"><a href="#顺序查找与折半查找" class="headerlink" title="顺序查找与折半查找"></a>顺序查找与折半查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   ElemType *elem; <span class="comment">//0号单元留空</span></span><br><span class="line">   <span class="type">int</span> TableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span>&#123;</span><br><span class="line">   ST.elem[<span class="number">0</span>] = key;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = ST.TableLen;ST.elem[i]!=key;--i);</span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   注意此处“哨兵”的引入，可避免很多不必要的判断语句。</p>
<p>   当查找成功时，顺序查找的平均长度为<br>$$<br>   ASL_{成功} &#x3D; \sum_{i&#x3D;1}^nP_i(n-i+1)<br>$$<br>   当每个元素的查找概率相等，即P<del>i</del> &#x3D; 1&#x2F;n时，有<br>$$<br>   ASL_{成功} &#x3D; \sum_{i&#x3D;1}^nP_i(n-i+1) &#x3D; \frac{n+1}{2}<br>$$<br>   查找不成功时<br>$$<br>   ASL_{不成功} &#x3D; n + 1<br>$$<br>   综上，顺序查找的缺点是当n较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序、链式存储皆可。需注意，对线性的链表只能进行顺序查找。</p>
<blockquote>
<p>对于有序表的顺序查找，其查找成功的平均查找长度与一般线性表的顺序查找一样。其查找不成功的平均查找长度在相等查找概率下的情形为<br>   $$<br>   ASL_{不成功} &#x3D; \sum_{j&#x3D;1}^nq_j(l_j-1) &#x3D; \frac{1+2+…+n+n}{n+1} &#x3D; \frac{n}{2} + \frac{n}{n+1}<br>   $$<br>注意，有序线性表的顺序查找表和后面的折半查找的思想是不一样的，且有序线性表的顺序查找可以是链式存储结构。</p>
</blockquote>
<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>   折半查找又称二分查找，它仅适用于有序的顺序表。<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SSTable L,ElemType key)</span>&#123;</span><br><span class="line">   <span class="type">int</span> low = <span class="number">0</span>,high = L.TableLen - <span class="number">1</span>,mid;</span><br><span class="line">   <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">      mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(L.elem[mid] == key)&#123;</span><br><span class="line">         <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)&#123;</span><br><span class="line">         high = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         low = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   查找成功的平均查找长度为（等概率情况下）<br>$$<br>   ASL &#x3D; \frac{n}{1}\sum_{i&#x3D;1}{n}l_i &#x3D; \frac{1}{n}(1\times1+2\times2+…+h\times2^{h-1}) &#x3D; \frac{n+1}{n}\log_2(n+1)-1\approx\log_2(n+1)-1<br>$$<br>   式中，h是树的高度，并且元素个数为n时树高为$h &#x3D; \lceil\log_2(n+1)\rceil$。所以，折半查找的时间复杂度为$O(\log_2n)$，平均情况下比顺序查找的效率高。</p>
<blockquote>
<p>由于折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。</p>
</blockquote>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>   分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。</p>
<p>   设索引查找和块内查找的平均查找长度为L<del>1</del>,L<del>s</del>,则分块查找的平均查找长度为$ASL &#x3D; L_1+L_s$</p>
<p>   设长度为n的查找表均匀地分为b块，每块有s个记录，在等概率情况下，若在块内和索引表中顺序查找，则平均查找长度为：<br>$$<br>   ASL &#x3D; L_1+L_s &#x3D; \frac{b+1}{2}+\frac{s+1}{2} &#x3D; \frac{s^2+2s+n}{2s}<br>$$<br>   此时，若$s &#x3D; \sqrt{n}$，则平均查找长度取最小值$\sqrt{n}+1$</p>
<h4 id="性质补充"><a href="#性质补充" class="headerlink" title="性质补充"></a>性质补充</h4><p>   折半查找算法在选取中间节点时，要么采用向上取整的方式，要么采用向下取整的方式。可凭借此来判断某棵树是否能称为折半查找判定树。参考P255T21</p>
<p>   由于折半查找的判定树是一棵二叉排序树，对于一个序列是否满足构成折半查找中关键字比较序列，可以将此序列化为排序树，看其是否符合要求。参考T254T19</p>
<h3 id="树型查找"><a href="#树型查找" class="headerlink" title="树型查找"></a>树型查找</h3><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>   构造一棵二叉排序树不是为了排序，而是为了提高查找，插入、删除关键字的速度。二叉排序树这种非线性结构也有利于插入和删除的实现。</p>
<ol>
<li><p>二叉排序树的定义</p>
</li>
<li><p>二叉排序树的查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BiTree T,ElemType key)</span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;data)&#123;</span><br><span class="line">      <span class="keyword">if</span>(key&lt;t-&gt;data)T = T-&gt;lchild;</span><br><span class="line">      <span class="keyword">else</span> T = T-&gt;rchild;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二叉排序树的插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BiTree &amp;T,KeyType k)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">      T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">      T-&gt;data = k;</span><br><span class="line">      T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;data)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;data)</span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二叉排序树的构造</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BiTree &amp;T,KeyType str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   T = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">      BST_Insert(T,str[i]);</span><br><span class="line">      i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二叉排序树的删除</p>
</li>
</ol>
<ul>
<li>若被删除结点z是叶节点，则直接删除，不会破坏二叉排序树的性质。</li>
<li>若结点z只有一棵左子树或右子树，则让z的子树成为z父节点的子树，替代z的位置。</li>
<li>若结点z有左右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一种或第二种情况。</li>
</ul>
<ol start="6">
<li>二叉排序树的查找效率分析</li>
</ol>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><ol>
<li><p>平衡二叉树的定义</p>
<p>任意结点的左右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树，或称AVL树。定义结点左子树与右子树的高度差为该节点的平衡因子，则平衡二叉树的平衡因子的值只可能是-1，0或1。</p>
</li>
<li><p>平衡二叉树的插入</p>
<p>平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新节点chacha入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列四种情况：</p>
<ol>
<li><p>LL平衡旋转（右单旋转）</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230613155442769.png" alt="image-20230613155442769"></p>
</li>
<li><p>RR平衡旋转（左单旋转）</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230613155509401.png" alt="image-20230613155509401"></p>
</li>
<li><p>LR平衡旋转（先左后右双旋转）</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230613155516345.png" alt="image-20230613155516345"></p>
</li>
<li><p>RL平衡旋转（先右后左双旋转） </p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230613155540313.png" alt="image-20230613155540313"></p>
</li>
<li><p>平衡二叉树的构造</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230613155731220.png" alt="image-20230613155731220"></p>
</li>
</ol>
</li>
<li><p>平衡二叉树的删除</p>
<p>删除节点w（依据二叉排序树的删除方法）后，若导致不平衡，则从节点w开始向上回溯，找到第一个不平衡的节点z（即最小不平衡子树），y为节点z的高度最高的孩子节点，x是节点y的高度最高的孩子节点。然后对以z为子根的子树进行平衡调整，其中x，y，z可能的位置有4种情况：</p>
<ul>
<li>y是z的左孩子，x是y的左孩子（LL，右单旋转）</li>
<li>y是z的右孩子，x是y的右孩子（RR，左单旋转）</li>
<li>y是z的右孩子，x是y的左孩子（RL，先右后左双旋转）</li>
<li>y是z的左孩子，x是y的右孩子（LR，先左后右双旋转）</li>
</ul>
</li>
<li><p>平衡二叉树的查找</p>
<p>以n<del>h</del>表示深度为h的平衡树中含有的最少节点数，显然有n<del>0</del> &#x3D; 0，n<del>1</del> &#x3D; 1，n<del>2</del> &#x3D; 2，并且有n<del>h</del> &#x3D; n<del>h-1</del> + n<del>h-2</del> + 1。其中n<del>h</del>为构造此高度的平衡二叉树所需的最少结点数。</p>
</li>
</ol>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ol>
<li><p>红黑树的定义</p>
<p>红黑树是满足如下红黑性质的二叉排序树：</p>
<ul>
<li>每个节点或是红色的，或是黑色的。</li>
<li>根节点是黑色的。</li>
<li>叶节点（虚构的外部节点、NULL节点）都是黑色的。</li>
<li>不存在两个相邻的红节点（即红节点的父节点和孩子节点均是黑色的）。</li>
<li>h对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同。</li>
</ul>
</li>
</ol>
<ul>
<li><p>从某结点出发（不含该节点）到达一个叶节点的任意一个简单路径上的黑节点总数称为该结点的黑高（记为bh），黑高的性质是由性质5决定的。根节点的黑高称为红黑树的黑高。</p>
<blockquote>
<p>结论1：从根到叶节点的最长路径不大于最短路径的2倍。</p>
</blockquote>
<blockquote>
<p> 结论2：有n个内部结点的红黑树的高度$h\leq 2\log_2(n+1)$.</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li><p>红黑树的插入</p>
<p>与二叉排序树插入类似，但需要进行调整（重新着色或旋转操作），以满足红黑树的性质。</p>
<blockquote>
<p>结论3：新插入红黑树中的结点初始着为红色。</p>
</blockquote>
<p>设节点z为新插入的结点，插入过程描述如下：<strong>（参考书P270）</strong></p>
<ol>
<li><p>用二叉查找树插入法插入，并将结点z着为红色，若结点z的父节点为黑色，则无需做任何调整，此时就是一棵标准的红黑树。</p>
</li>
<li><p>如果结点z是根节点，将z着为黑色（树的黑高增1），结束。</p>
</li>
<li><p>如果结点z不是根节点，并且z的父节点z.p是红色的，则分以下三种情况，区别在于z的叔结点y的颜色不同，因z.p是红色的，插入前的树是合法的，根据性质2和4，爷结点z.p.p必然存在且为黑色。性质4只在z和z.p之间被破坏了。</p>
<p><strong>以下情况建立在z.p为z.p.p的左孩子节点的基础上</strong></p>
<p>情况1：z的叔结点y是黑色的，且z是一个右孩子（LR，先做一个左旋转变为情况2）<br>情况2：z的叔结点y是黑色的，且z是一个左孩子（LL，并交换z.p和z.p.p的颜色）</p>
<p><strong>若z.p是z.p.p的右孩子，则还有两种对称的情况: RL和RR。</strong></p>
<p>情况3：（z是左孩子或右孩子无影响）,z的父节点z.p和叔节点y都是红色的，因为爷节点z.p.p是黑色的，将z.p和y都着为黑色，将z.p.p着为红色，以在局部保持性质4和5，然后，把z.p.p作为新节点z来重复循环，指针z在树中上移两层。</p>
</li>
</ol>
</li>
<li><p>红黑树的删除</p>
<p>红黑树的插入操作容易导致连续的两个红节点，破坏性质4。而删除操作容易造成子树黑高的变化（删除黑节点会导致根节点发哦叶节点间的黑节点数量减少），破坏性质5.</p>
<p>删除过程也是先执行二叉查找树的删除方法，若待删节点有两个孩子，不能直接删除，而要找到该节点的中序后继（或前驱）填补，即右子树中最小的节点，然后转换为删除该后继节点。由于后继节点至多只有一个孩子，这样就转换为待删节点是终端节点或仅有一个孩子的情况。</p>
<p>最终，删除一个节点有以下两种情况：</p>
<p>情况比较复杂，参考书P272-P274,这里不作赘述</p>
</li>
</ol>
<h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><h4 id="B树及其基本操作"><a href="#B树及其基本操作" class="headerlink" title="B树及其基本操作"></a>B树及其基本操作</h4><p>所谓m阶B树是所有结点的平衡因子均等于0的m路平衡查找树。</p>
<p>一棵m阶B树或为空树，或为满足如下特性的m叉树：</p>
<ol>
<li><p>树中每个结点至多有m棵子树，即至多含有m-1关键字</p>
</li>
<li><p>若根结点不是叶结点，则至少有两棵子树</p>
</li>
<li><p>除根结点外的所有非叶结点至少有$\lceil m&#x2F;2\rceil$棵子树，即至少含有$\lceil m&#x2F;2\rceil -1$个关键字。</p>
</li>
<li><p>所有非叶结点的结构如下：</p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230619164155434.png"/>
</li>
<li><p>所有的叶结点都出现在同一层次上，并且不带信息（可视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230619164501119.png" alt="image-20230619164501119"></p>
</li>
</ol>
<h5 id="1-B树的高度-磁盘存取次数"><a href="#1-B树的高度-磁盘存取次数" class="headerlink" title="1. B树的高度(磁盘存取次数)"></a>1. B树的高度(磁盘存取次数)</h5><p>B树的大部分操作所需的磁盘存取次数与B树的高度成正比。</p>
<p>若$n\geq1$，则对任意一棵包含n个关键字、高度为h、阶数为m的B树：</p>
<ol>
<li><p>因为B树中每个结点最多有m棵子树，m-1个关键字，所以在一棵高度为h的m阶B树中有：<br>$$<br>h\geq \log_m(n+1)<br>$$</p>
</li>
<li><p>若让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树高度达到最大。 第一层至少有1个结点；第二层至少有两个结点；除根结点外的每个非叶结点至少有$\lceil m&#x2F;2\rceil$棵子树，则第三层至少有$2\lceil m&#x2F;2\rceil$个结点。。。。。第h+1层至少有$2(\lceil m&#x2F;2\rceil)^{h-1}$个结点，注意到第h+1层是不包含任何信息的叶结点。</p>
</li>
</ol>
<p>对于关键字个数为n的B树，叶结点即查找不成功的结点n+1，由此有$n+1\geq 2(\lceil m&#x2F;2\rceil)^{h-1}$，即$h\leq \log_{\lceil m&#x2F;2\rceil}((n+1)&#x2F;2)+1$</p>
<h5 id="2-B树的查找"><a href="#2-B树的查找" class="headerlink" title="2. B树的查找"></a>2. B树的查找</h5><ol>
<li><p>在B树中找结点</p>
</li>
<li><p>在结点内找关键字</p>
<blockquote>
<p>由于B树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点信息读入内存，然后在节点内采用顺序查找法或折半查找法。</p>
</blockquote>
</li>
</ol>
<h5 id="3-B树的插入"><a href="#3-B树的插入" class="headerlink" title="3. B树的插入"></a>3. B树的插入</h5><ol>
<li><p>定位</p>
</li>
<li><p>插入</p>
<p>当插入后的结点关键字个数小于m，可以直接插入；当插入后结点关键字个数大于m-1时，必须对结点进行分裂。分裂的方法如下：</p>
<img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230619194616002.png"/></li>
</ol>
<h5 id="4-B树的删除"><a href="#4-B树的删除" class="headerlink" title="4. B树的删除"></a>4. B树的删除</h5><p>要使得删除后的结点中的关键字个数$\geq \lceil m&#x2F;2\rceil -1$，因此涉及结点的“合并”问题</p>
<p>当被删关键字k不在终端节点（最底层的非叶结点）中时，可以用k的前驱（或后继）k`来替代k，然后在相应的结点中删除k`，关键字k`必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230619195405159.png" alt="image-20230619195405159"></p>
<h4 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B+树的基本概念"></a>B+树的基本概念</h4><p>B+树是应数据库所需而出现的一种B树的变形树。</p>
<p>一棵m阶的B+树需满足下列条件：</p>
<ol>
<li>每个分支节点最多有m棵子树（孩子结点）</li>
<li>非叶根结点至少有两棵子树，其他两个分支结点至少有$\lceil m&#x2F;2\rceil$棵子树</li>
<li><strong>结点的子树个数与关键字树相等</strong></li>
<li>所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互连接起来。</li>
<li>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230619200521839.png" alt="image-20230619200521839"></p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h4 id="散列表的基本概念"><a href="#散列表的基本概念" class="headerlink" title="散列表的基本概念"></a>散列表的基本概念</h4><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash（key） &#x3D; Addr（这里的地址可以是数组下标、索引或内存地址等）</p>
<p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些发生碰撞的不同关键字称为同义词。</p>
<p>散列表：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
<p>理想情况下，对散列表进行查找的时间复杂度为O(1)</p>
<h4 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h4><p>   在构造散列函数时需要注意以下几点：</p>
<p>1.散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</p>
<p>2.散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。</p>
<p>3.散列函数应尽量简单，能够在较短的时间内计算出任意一个关键字对应的散列地址。</p>
<p>   下面是常用的散列函数。</p>
<ol>
<li><p>直接定址法<br>$$<br>H(key) &#x3D; key或H(key) &#x3D; a\times key + b\<br>a,b为常数。<br>$$<br>   这种方法适合于关键字分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p>
</li>
<li><p>除留余数法</p>
</li>
</ol>
<p>假设散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为<br>$$<br>H(key) &#x3D; key%p<br>$$<br>      除留余数法的关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任意一个地址，从而尽可能减少冲突的可能性。</p>
<ol start="3">
<li>数字分析法</li>
</ol>
<p>适合于已知的关键字集合，若更换关键字，则需要重新构造新的散列函数。</p>
<ol start="4">
<li>平方取中法</li>
</ol>
<p>适合于关键字的每位取值都不够均匀或均小于散列地址所需的位数。</p>
<h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4><ol>
<li>开放定址法</li>
</ol>
<p>$$<br>H_i &#x3D; (H(key)+d_i)%m\<br>H(key)为散列函数；\<br>i &#x3D; 0, 1, 2, … k(k&lt;m-1);\<br>m表示散列表表长;\<br>d_i为增量序列。<br>$$</p>
<p>取增量序列的方法：</p>
<pre><code>  1. 线性探测法

  2. 平方探测法

  3. 双散列法

  4. 伪随机序列法
</code></pre>
<ol start="2">
<li>拉链法（链接法，chaining）</li>
</ol>
<p>为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。</p>
<p>拉链法适用于经常插入和删除的情况。</p>
<h4 id="散列查找及性能分析"><a href="#散列查找及性能分析" class="headerlink" title="散列查找及性能分析"></a>散列查找及性能分析</h4><p><strong>注意平均查找长度的计算</strong></p>
<p>散列表的装填因子一般记为$\alpha$，定义为一个表的装满程度，即<br>$$<br>\alpha &#x3D; \frac{表中记录数}{散列表长度}<br>$$<br>散列表的平均查找长度依赖于散列表的装填因子$\alpha$，而不直接依赖于n和m。直观地看，$\alpha$越大，表示装填的记录越慢，发生冲突的可能性越大。</p>
<h2 id="7-排序"><a href="#7-排序" class="headerlink" title="7. 排序"></a>7. 排序</h2><h3 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h3><h4 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a>排序的定义</h4><p>排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。</p>
<p>算法的稳定性：若两个元素关键字相同，排序前与排序后两个元素的相对排序不变，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p>
<p>在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类</p>
<ol>
<li><p>内部排序</p>
<p>在排序期间元素全部存放在内存中的排序。</p>
</li>
<li><p>外部排序</p>
<p>在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。</p>
</li>
</ol>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">         A[<span class="number">0</span>] = A[i];</span><br><span class="line">         <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];j--)&#123;</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">         &#125;</span><br><span class="line">         A[j+<span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析如下：</p>
<blockquote>
<p>空间效率：仅使用了常数个辅助单元，因此空间复杂度为O(1)</p>
</blockquote>
<blockquote>
<p>时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。</p>
<p>在最好情况下，表中元素已有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O(n)</p>
<p>在最坏情况下，表中元素恰好逆序，总的比较次数和移动次数都达到最大，总的时间复杂度为$O(n^2)$</p>
<p>平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为$n^2&#x2F;4$</p>
</blockquote>
<blockquote>
<p>因此，直接插入排序的时间复杂度为$O(n^2)$</p>
</blockquote>
<blockquote>
<p>稳定性：由于每次插入元素时总是从后向前比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。</p>
</blockquote>
<blockquote>
<p>适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</p>
</blockquote>
<h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j,high,low;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      A[<span class="number">0</span>] = A[i];</span><br><span class="line">      low=<span class="number">1</span>;high=i<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">         <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>])</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;j--)&#123;</span><br><span class="line">         A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">      &#125;</span><br><span class="line">      A[high+<span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析如下：</p>
<blockquote>
<p>从上述算法中，不难看出折半插入排序<strong>仅减少了比较元素的次数</strong>，约为$O(n\log_2n)$，该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n，而元素的移动次数并未改变，它依赖于待排序表的初始状态。</p>
<p>因此，折半插入排序的时间复杂度仍为$O(n^2)$,但对于数据量不很大的排序表，折半插入排序往往能表现出很好的性能。</p>
<p>折半插入排序是一种稳定的排序方法。</p>
</blockquote>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="type">int</span> dk,i,j;</span><br><span class="line">   <span class="keyword">for</span>(dk = n/<span class="number">2</span>;dk &gt;= <span class="number">1</span>;dk = dk/<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(i = dk+<span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(A[i] &lt; A[i-dk])&#123;</span><br><span class="line">            A[<span class="number">0</span>] = A[j];</span><br><span class="line">            <span class="keyword">for</span>(j = i-dk;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=dk)&#123;</span><br><span class="line">               A[j+dk] = A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            A[j+dk] = A[<span class="number">0</span>];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<blockquote>
<p>空间效率：仅使用了常数个辅助单元，因此空间复杂度为O(1)</p>
</blockquote>
<blockquote>
<p>时间效率：在某个特定范围时，希尔排序的时间复杂度约为$(O^{1.3})$，在最坏情况下希尔排序的时间复杂度为$O(n^2)$</p>
</blockquote>
<blockquote>
<p>稳定性：不稳定。</p>
</blockquote>
<blockquote>
<p>适用性：仅适用于线性表为顺序存储的情况。</p>
</blockquote>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">      <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">         <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;</span><br><span class="line">            swap(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(flag == <span class="literal">false</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span>;<span class="comment">//已有序</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<blockquote>
<p>空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1)</p>
</blockquote>
<blockquote>
<p>时间效率：</p>
<p>最好情况(有序):比较次数n-1，移动次数0，时间复杂度O(n)</p>
<p>最坏情况(逆序):比较次数$\frac{n(n-1)}{2}$，移动次数$\frac{3n(n-1)}{2}$</p>
<p>从而，最坏情况下的时间复杂度为$O(n^2)$，平均时间复杂度为$O(n^2)$。</p>
</blockquote>
<blockquote>
<p>稳定性：稳定。</p>
</blockquote>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">      <span class="type">int</span> pivotpos = Partition(A,low,high);</span><br><span class="line">      QuickSort(A,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">      QuickSort(A,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="title function_">Partition</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">   ElemType pivot = A[low];</span><br><span class="line">   <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">      <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot) --high;</span><br><span class="line">      A[low] = A[high];</span><br><span class="line">      <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot) ++low;</span><br><span class="line">      A[high] = A[low];</span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<blockquote>
<p>空间效率：最好情况下，$O(\log_2n)$,最坏情况下，$O(n)$</p>
<p>平均情况下：$O(\log_2n)$</p>
</blockquote>
<blockquote>
<p>时间效率：最好情况下，$O(n\log_2n)$,最坏情况下，$O(n^2)$</p>
<p>平均情况下：$O(n\log_2n)$</p>
</blockquote>
<blockquote>
<p>稳定性：不稳定。</p>
</blockquote>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">      <span class="type">int</span> min = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(A[min]&gt;A[j]) min = j;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(min != i)swap(A[i],A[min]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<blockquote>
<p>空间效率：O(1)</p>
</blockquote>
<blockquote>
<p>时间效率：</p>
<p>移动次数：0~3(n-1)，与序列初始状态有关</p>
<p>比较次数：n(n-1)&#x2F;2，与序列初始状态无关</p>
<p>时间复杂度：$O(n^2)$</p>
</blockquote>
<blockquote>
<p>稳定性：不稳定。</p>
</blockquote>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BulidMaxHeap</span><span class="params">(ElemType A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">      HeadAdjust(A,i,len);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(ElemType A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">   A[<span class="number">0</span>] = A[k];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">         i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i])<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         A[k] = A[i];</span><br><span class="line">         k = i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   A[k] = A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(ElemType A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">   BulidMaxHeap(A,len);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">      swap(A[i],A[<span class="number">1</span>]);</span><br><span class="line">      HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序适用于关键字较多的情况。</p>
<p>性能分析：</p>
<blockquote>
<p>空间效率：O(1)</p>
</blockquote>
<blockquote>
<p>时间效率：<br>建堆时间为O(n),之后有n-1次向下调整操作，每次调整的时间为O(h),故在最好、最坏以及平均情况下，堆排序的时间复杂度为$O(n\log_2n)$</p>
</blockquote>
<blockquote>
<p>稳定性：不稳定。 </p>
</blockquote>
<h3 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ElemType *B = (ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*sizeod(ElemType));</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">   <span class="type">int</span> i,j,k;</span><br><span class="line">   <span class="keyword">for</span>(k = low;k&lt;high;k++)</span><br><span class="line">   &#123;</span><br><span class="line">      B[k] = A[k];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i = low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(B[i]&lt;B[j])</span><br><span class="line">         A[k] = B[i++];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         A[k] = B[j++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;=mid) A[k++] = B[i++];</span><br><span class="line">   <span class="keyword">while</span>(j&lt;=high) A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">      <span class="type">int</span> mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">      MergeSort(A,low,mid);</span><br><span class="line">      MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">      Merge(A,low,mid,high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能分析：</p>
<blockquote>
<p>空间效率：O(n)</p>
</blockquote>
<blockquote>
<p>时间效率：每趟归并的时间复杂度为O(n),共需进行$\lceil \log_2n\rceil$趟归并，所以算法的时间复杂度为$O(n\log_2n)$</p>
</blockquote>
<blockquote>
<p>稳定性：稳定。</p>
</blockquote>
<blockquote>
<p>注意：一般而言，对于N个元素进行k路归并排序时，排序的趟数m满足$k^m &#x3D; N$，从而$m&#x3D;\log_kN$，又考虑到m为整数，所以$m &#x3D; \lceil log_kN\rceil$。这和前面的2路归并是一致的。</p>
</blockquote>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>性能分析：</p>
<blockquote>
<p>空间效率：一趟排序需要的辅助存储空间为r（r个队列：r个队头指针和队尾指针），但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为O(r)</p>
</blockquote>
<blockquote>
<p>时间效率：进行d趟分配与收集，一趟分配需要O(n),一趟收集需要O(r),所以基数排序的时间复杂度为O(d(n+r)),它与序列的初始状态无关。</p>
</blockquote>
<blockquote>
<p>稳定性：稳定。</p>
</blockquote>
<h3 id="各种内部排序算法的比较及应用"><a href="#各种内部排序算法的比较及应用" class="headerlink" title="各种内部排序算法的比较及应用"></a>各种内部排序算法的比较及应用</h3><h4 id="内部排序算法的比较"><a href="#内部排序算法的比较" class="headerlink" title="内部排序算法的比较"></a>内部排序算法的比较</h4><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230625111923314.png"/>

<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230625111956279.png" alt="image-20230625111956279"></p>
<h4 id="内部排序算法的应用"><a href="#内部排序算法的应用" class="headerlink" title="内部排序算法的应用"></a>内部排序算法的应用</h4><ol>
<li><p>选取排序方法需要考虑的因素</p>
<ol>
<li><p>待排序的元素数目n</p>
</li>
<li><p>元素本身信息量的大小</p>
</li>
<li><p>关键字的结构及其分布情况</p>
</li>
<li><p>稳定性的要求</p>
</li>
<li><p>语言工具的条件，存储结构及辅助空间的大小等。</p>
</li>
</ol>
</li>
<li><p>排序算法小结</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20230625112306359.png" alt="image-20230625112306359"></p>
</li>
</ol>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><p>主要内容：</p>
<ol>
<li><p>外部排序指待排序文件较大，内存一次放不下，需存放在外存的文件的排序。</p>
</li>
<li><p>为减少平衡归并中外存读写次数所采取的方法：增大归并路数和减少归并段个数。</p>
</li>
<li><p>利用败者树增大归并路数。</p>
</li>
<li><p>利用置换-选择排序增大归并段长度来减少归并段个数。</p>
</li>
<li><p>由长度不等的归并段，进行多路平衡归并，需要构造最佳归并树。</p>
</li>
</ol>
<h4 id="外部排序的基本概念"><a href="#外部排序的基本概念" class="headerlink" title="外部排序的基本概念"></a>外部排序的基本概念</h4><h4 id="外部排序的方法"><a href="#外部排序的方法" class="headerlink" title="外部排序的方法"></a>外部排序的方法</h4><h4 id="多路平衡归并与败者树"><a href="#多路平衡归并与败者树" class="headerlink" title="多路平衡归并与败者树"></a>多路平衡归并与败者树</h4><h4 id="置换-选择排序（生成初始归并段）"><a href="#置换-选择排序（生成初始归并段）" class="headerlink" title="置换-选择排序（生成初始归并段）"></a>置换-选择排序（生成初始归并段）</h4><h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/dataStructure/" data-id="clqwhyhx1000rikvff7w2bjiw" data-title="data Structure" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/data-Structure/" rel="tag">data Structure</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-computer network" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/02/computer%20network/" class="article-date">
  <time class="dt-published" datetime="2024-01-02T15:20:45.733Z" itemprop="datePublished">2024-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/02/computer%20network/">Computer network</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="第一章-计算机网络体系结构"><a href="#第一章-计算机网络体系结构" class="headerlink" title="第一章 计算机网络体系结构"></a>第一章 计算机网络体系结构</h2><ol>
<li>数据链路层、网络层、传输层都具有流量控制和差错控制功能，区别在于数据链路层的流量控制在点对点之间，网络层在整个网络中进行流量控制，传输层在端到端之间进行流量控制。</li>
<li>网络层和传输层都有拥塞控制功能。</li>
<li>会话层允许不同主机上的各个进程之间进行对话，及建立<strong>同步</strong>。</li>
<li>表示层主要处理在两个通信系统中交换信息的表示方式。</li>
<li>物理层不参与数据封装工作。</li>
<li>OSI参考模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP&#x2F;IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。</li>
<li>协议由语法、语义和同步三部分构成。语法？（格式）语义？（功能）同步？（时间）</li>
</ol>
<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><ol>
<li>信道是信号的传输媒介。一个信道可视为一条线路的逻辑部件，一般用来表示想某个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。</li>
<li>信道上传输的信号由基带信号和宽带信号之分。基带信号将数字信号直接用电压表示，然后送到数字信道上传输，称为<strong>基带传输</strong>；宽带信号将基带信号进行调制后形成频分复用模拟信号，然后送到模拟信道上传输，称为<strong>宽带传输</strong></li>
<li>奈奎斯特定理表明了什么？香农定理表明了什么？</li>
<li>数字数据<strong>编码</strong>为数字信号的方法：归零编码，非归零编码，反向非归零编码（<strong>USB2.0</strong>)，曼彻斯特编码（<strong>以太网</strong>），差分曼彻斯特编码，4B&#x2F;5B编码。</li>
<li>数字数据<strong>调制</strong>为模拟信号的方法：ASK，FSK，PSK，QAM</li>
<li>模拟数据<strong>编码</strong>为数字信号：采样、量化、编码</li>
<li>模拟数据<strong>调制</strong>为模拟信号（频分复用FDM，多用于声音信号传输）</li>
<li>电路交换不具有差错控制功能，但传输时延小。</li>
<li>报文交换数据经过网络的传输延迟长且不固定，不能用于语音数据传输。</li>
<li>虚电路不都是临时的，有永久性虚电路和交换型虚电路两者之分。</li>
<li>10BaseT即10Mb&#x2F;s的以太网。</li>
<li>中继器的功能是将信号整形并放大再转发出去，其端口仅作用于信号的电气部分，而不管是否有错误数据或不适于网段的数据，中继器不能连接两个不同速率的局域网。</li>
<li>理论上讲，中继器使用数目无限，网络因而也可以无限延长。但事实上应遵循5-4-3原则。</li>
<li>放大器和中继器都起放大作用，放大器放大的是模拟信号，原理是将衰减的信号放大，而中继器放大的是数字信号，原理是将衰减的信号整形再生。</li>
<li>集线器实质上是一个多端口的中继器，是一个标准的共享型设备，其主要使用双绞线组建共享网络，在半双工状态下工作</li>
<li>在网络中使用集线器，其物理拓扑为星型，逻辑拓扑为总线型。</li>
<li>在以太网中，逻辑拓扑为总线型，物理为总线型或星型。</li>
</ol>
<h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><ol>
<li><p>数据链路层通常可为网络层提供如下服务：</p>
<ol>
<li>无确认的无连接服务，适用于实时通信或误码率较低的通信信道，如以太网。</li>
<li>有确认的无连接服务，适用于误码率较高的通信信道，如无线通信。</li>
<li>有确认的面向连接服务，适用于通信要求（可靠性、实时性）较高的场合。</li>
</ol>
</li>
<li><p>所谓透明传输就是不管所传数据是怎样的比特组合（即使为与帧结束符相同的比特串），都应当能在链路上传输。</p>
</li>
<li><p>流量控制对于数据链路层来说，控制的是相邻两结点之间数据链路上的流量，而对于传输层来说，控制的则是从源端到目的端之间的流量。</p>
</li>
<li><p>组帧方法：字符计数法、字符填充的首尾定界符法、零比特填充的首尾标志法、违规编码法</p>
<p>其中，零比特填充法很容易由硬件来实现，性能优于字符填充法；违规编码法只适用于采用冗余编码的特殊编码环境。</p>
</li>
<li><p>差错控制</p>
<ol>
<li>检错<ol>
<li>奇偶校验码：只能检验奇数位的校验情况，但不知道哪些位错了，也不能检验偶数位的情况。</li>
<li>循环冗余码</li>
</ol>
</li>
<li>海明码：<ol>
<li>$n+k \leq 2^k-1$</li>
<li>$校验位P_i分布在2^{i-1}的位置$</li>
<li><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20231020165453688.png" alt="image-20231020165453688"></li>
</ol>
</li>
</ol>
</li>
<li><p>通过提高信噪比可以减弱其影响的差错是随机差错。</p>
</li>
<li><p>CRC校验码可以检测出所有的单比特错误</p>
</li>
<li><p>海明码可以纠正一位差错</p>
</li>
<li><p>海明码纠错d位，需要码距2d+1，检错d位，需要码距d+1</p>
</li>
<li><p>带r个校验位的多项式编码可以检测到所有长度小于或等于r的突发性错误</p>
</li>
<li><p>CRC校验可以使用硬件完成</p>
</li>
<li><p>从滑动窗口的概念看，停止-等待协议、后退N帧协议和选择重传协议只在发生窗口和接受窗口大小上有所差别：</p>
<ol>
<li>停止-等待协议：发送窗口大小 &#x3D; 1，接收窗口大小 &#x3D; 1</li>
<li>后退N帧协议：发送窗口大小 &gt; 1，接收窗口大小 &#x3D; 1</li>
<li>选择重传协议：发送窗口大小 &gt; 1，接收窗口大小 &gt; 1</li>
</ol>
</li>
<li><p>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意与第五章传输层的滑动窗口协议的区别）</p>
</li>
<li><p>在数据链路层中流量控制机制和可靠传输机制是交织在一起的。</p>
</li>
<li><p>ACKn表示对n号帧的确认，下一次期望收到第n+1号帧（也可能是第0号帧）</p>
</li>
<li><p>后退N帧协议要求发送窗口的尺寸$1\leq W_T\leq 2^n-1$</p>
</li>
<li><p>选择重传协议要求发送窗口和接收窗口的尺寸$W_{Tmax} &#x3D; W_{Rmax} &#x3D; 2^{n-1}$</p>
</li>
<li><p>介质访问控制方法</p>
<ol>
<li><p>信道划分介质访问控制</p>
<ol>
<li>频分多路复用（FDM）：适合传输模拟信号</li>
<li>时分多路复用（TDM）：适合传输数字信号</li>
<li>波分多路复用（WDM）：光的频分复用</li>
<li>码分多路复用（CDM）：具有频谱利用率高，抗干扰能力强，保密性强，语音质量好等优点，还可减少投资和运行成本，主要用于无线通信系统，特别是移动通信系统</li>
</ol>
</li>
<li><p>随机访问介质访问控制，又称争用型</p>
<ol>
<li><p>ALOHA</p>
<ol>
<li>纯ALOHA</li>
<li>时隙ALOHA</li>
</ol>
</li>
<li><p>CSMA</p>
<ol>
<li>1-坚持CSMA</li>
<li>非坚持CSMA</li>
<li>p-坚持CSMA：用于时分信道</li>
</ol>
</li>
<li><p>CSMA&#x2F;CD：适用于总线型网络或半双工网络环境</p>
<p>最短帧长即为争用期内可发送的数据长度，最小帧长 &#x3D; 总线传播时延 * 数据传输速率 * 2</p>
<p>以太网规定取51.2us为争用期的长度，对于10Mb&#x2F;s的以太网，在争用期内可发送512b，也就是64B</p>
<p>适用截断二进制算法解决碰撞问题，若重传次数达16次则抛弃此帧并向高层报告出错</p>
</li>
<li><p>CSMA&#x2F;CA：广泛应用于无线局域网</p>
</li>
</ol>
</li>
<li><p>轮询访问介质访问控制</p>
<p>令牌传递协议，主要用于令牌环局域网中，物理拓扑不必是一个环，但逻辑拓扑必须是一个环</p>
</li>
</ol>
</li>
<li><p>无线局域网不使用CSMA&#x2F;CD而使用CSMA&#x2F;CA的原因是，无线局域网不需要在发送过程中进行冲突检测。</p>
</li>
<li><p>局域网拓扑结构主要有以下4大类：</p>
<ol>
<li>星形结构</li>
<li>环形结构</li>
<li>总线形结构</li>
<li>星形和总线形结合的复合型结构</li>
</ol>
</li>
<li><p>局域网可以使用双绞线、铜缆和光纤等多种传输介质；其中双绞线为主流传输介质</p>
</li>
<li><p>以太网的逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构</p>
</li>
<li><p>令牌环的逻辑拓扑是环形结构，物理拓扑是星形结构</p>
</li>
<li><p>FDDI（光纤分布数字接口）逻辑拓扑是环形结构，物理拓扑是双环结构</p>
</li>
<li><p>IEEE802标准将数据链路层划分为两个子层：逻辑链路控制（LLC）子层和媒体接入控制（MAC）子层。与接入传输媒体有关的内容都放在MAC子层，它向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，主要功能包括：组帧和拆卸帧、比特传输差错检测、透明传输。LLC子层与传输媒体无关，它向网络层提供确认和无连接、面向连接、带确认无连接、高速传送4种不同的连接服务类型。</p>
</li>
<li><p>以太网的各种传输介质的使用情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/shenqiangle/hexo_images/images/image-20231021190446151.png" alt="image-20231021190446151"></p>
</li>
<li><p>网卡的重要功能就算进行数据的串并转换</p>
</li>
<li><p>网卡工作在数据链路层和物理层</p>
</li>
<li><p>速率达到或超过100Mb&#x2F;s的以太网称为高速以太网</p>
<ol>
<li><p>100BASE-T</p>
<p>双绞线、星形拓扑、使用CSMA&#x2F;CD、既支持全双工，又支持半双工，可在全双工方式下工作而无冲突发生</p>
<p>最短帧长不变，一个网段的最大电缆长度减少到100m。帧间间隔从原来的9.6us改为现在的0.96us</p>
</li>
<li><p>吉比特以太网</p>
<p>全双工、半双工，与10BASE-T和100BASE-T向后兼容</p>
</li>
<li><p>10吉比特以太网</p>
<p>使用光纤作为传输媒体，只工作在全双工方式下。</p>
</li>
</ol>
</li>
<li><p>802.11使用星形拓扑，其中心称为接入点AP，在MAC层使用CSMA&#x2F;CA协议。使用802.11系列协议的局域网又称wifi，无线局域网的服务范围直径一般不超过100m。</p>
</li>
<li><p>802.11帧的三个地址字段以及来自AP和去往AP两个字段的意义。</p>
</li>
<li><p>以太网（MAC协议）采用的是无确认的无连接服务。</p>
</li>
<li><p>吉比特以太网的物理层有两个标准，分别采用光纤通道和4对UTP5类线</p>
</li>
<li><p>VLAN建立在交换技术的基础上，以软件方式实现逻辑分组与管理</p>
</li>
<li><p>广域网强调资源共享，局域网强调数据传输</p>
</li>
<li><p>常见的广域网数据链路层协议是PPP和HDLC</p>
</li>
<li><p>PPP是面向字节的，所有PPP帧的长度都是整数个字节</p>
</li>
<li><p>PPP的特点：</p>
<ol>
<li>PPP提供差错检测但不提供纠错功能，只保证无差错接收（通过硬件进行CRC校验），它是不可靠的传输协议，因此也不使用序号和确认机制。</li>
<li>它仅支持点对点的链路通信，不支持多点线路</li>
<li>PPP只支持全双工</li>
<li>PPP两端可运行不同的网络层协议，但仍然可使用同一个PPP通信</li>
<li>PPP是面向字节的，当信息字段出现和标志字段一样的比特组合时，有两种处理方法：若PPP用在异步线路（默认），则采用字符填充法；若PPP用在同步线路，则协议规定采用硬件来完成比特填充</li>
</ol>
</li>
<li><p>当PPP帧协议字段值为0x0021，说明信息字段为IP数据报</p>
</li>
<li><p>以太网交换机实质上就算一个多端口的网桥，通常都工作在全双工方式，交换机的最大优点为：拥有N个端口的交换机总容量为N*10Mb&#x2F;s</p>
</li>
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/02/computer%20network/" data-id="clqwhy1e40000ikvf356xb51a" data-title="Computer network" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Computer-network/" rel="tag">Computer network</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JavaScript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/31/JavaScript/" class="article-date">
  <time class="dt-published" datetime="2022-10-31T03:19:11.000Z" itemprop="datePublished">2022-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/31/JavaScript/">JavaScript</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> JavaScript知识点入门简记</p>
        
          <p class="article-more-link">
            <a href="/2022/10/31/JavaScript/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/31/JavaScript/" data-id="clqwhy47t0009ikvf5xzk3gj1" data-title="JavaScript" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-composition-principle/" rel="tag">Computer composition principle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Computer-network/" rel="tag">Computer network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/" rel="tag">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS-XV6-labs-2021/" rel="tag">OS_XV6_labs_2021</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-Structure/" rel="tag">data Structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/os/" rel="tag">os</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/Computer-composition-principle/" style="font-size: 10px;">Computer composition principle</a> <a href="/tags/Computer-network/" style="font-size: 10px;">Computer network</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Math/" style="font-size: 10px;">Math</a> <a href="/tags/OS-XV6-labs-2021/" style="font-size: 10px;">OS_XV6_labs_2021</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/data-Structure/" style="font-size: 10px;">data Structure</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/os/" style="font-size: 10px;">os</a> <a href="/tags/typescript/" style="font-size: 10px;">typescript</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/02/Computer%20composition%20principle/">Computer composition principle</a>
          </li>
        
          <li>
            <a href="/2024/01/02/algorithm/">algorithm</a>
          </li>
        
          <li>
            <a href="/2024/01/02/typescript/">typescript</a>
          </li>
        
          <li>
            <a href="/2024/01/02/os/">os</a>
          </li>
        
          <li>
            <a href="/2024/01/02/npm/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>